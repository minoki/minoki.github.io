<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>Mizuki's Blog</title>
        <link>https://minoki.github.io</link>
        <description><![CDATA[Posts about functional programming languages]]></description>
        <atom:link href="https://minoki.github.io/rss.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Sun, 31 Aug 2025 00:00:00 UT</lastBuildDate>
        <item>
    <title>An Unofficial Guide to What's New in GHC 9.14</title>
    <link>https://minoki.github.io/posts/2025-08-31-whats-new-in-ghc-9-14.html</link>
    <description><![CDATA[<p>I’ve been writing posts in Japanese over the past few years introducing new features in GHC.
I thought such posts might also be useful for readers in the English-speaking community, so with some help from tools like ChatGPT, I’ve translated the latest one into English.
I hope this will be helpful when you try out the new GHC.</p>
<p>The original Japanese article can be found at <a href="https://zenn.dev/mod_poppo/articles/whats-new-in-ghc-9-14">GHC 9.14の新機能</a>.</p>
<hr />
<p>GHC 9.14.1-alpha1 was released on August 20, 2025 (in the author’s timezone).</p>
<ul>
<li><a href="https://discourse.haskell.org/t/ghc-9-14-1-alpha1-released/12786">GHC 9.14.1-alpha1 released - Announcements - Haskell Community</a></li>
</ul>
<p>In this post, I’ll go through the new features in GHC 9.14, based on my own (somewhat subjective) perspective.</p>
<p>This article is not a comprehensive overview.
In particular, areas I’m less familiar with—like the RTS and Template Haskell—aren’t really covered.
Please also check out the official release notes:</p>
<ul>
<li><a href="https://downloads.haskell.org/ghc/9.14.0.20250819/docs/users_guide/9.14.1-notes.html">2.1. Version 9.14.1 — Glasgow Haskell Compiler 9.14.0.20250819 User’s Guide</a>
<ul>
<li><a href="https://gitlab.haskell.org/ghc/ghc/-/blob/ghc-9.14/docs/users_guide/9.14.1-notes.rst">docs/users_guide/9.14.1-notes.rst · ghc-9.14 · Glasgow Haskell Compiler / GHC · GitLab</a>
<!-- * [Changelog for base-4.22.0.0 | Hackage](https://hackage.haskell.org/package/base-4.22.0.0/changelog) --></li>
</ul></li>
<li><a href="https://gitlab.haskell.org/ghc/ghc/-/blob/ghc-9.14/libraries/base/changelog.md">libraries/base/changelog.md · ghc-9.14 · Glasgow Haskell Compiler / GHC · GitLab</a></li>
<li><a href="https://gitlab.haskell.org/ghc/ghc/-/wikis/migration/9.14">9.14 · Wiki · Glasgow Haskell Compiler / GHC · GitLab</a></li>
</ul>
<p>If you want to try out the alpha release with GHCup, you’ll need to add the <code>prereleases</code> channel.
See <a href="https://www.haskell.org/ghcup/guide/#release-channels">Release channels - User Guide - GHCup</a> for details.</p>
<pre><code>$ ghcup config add-release-channel prereleases
$ ghcup install ghc 9.14.0.20250819</code></pre>
<p>The reason I’m publishing this “what’s new” post while GHC is still in alpha is to encourage more people to give the alpha a try.
That way, we can catch as many issues as possible before the final release.
So, please do try it out!</p>
<h1 id="long-term-support-lts">Long-Term Support (LTS)</h1>
<ul>
<li><a href="https://www.haskell.org/ghc/blog/20250702-ghc-release-schedules.html">GHC LTS Releases — The Glasgow Haskell Compiler</a></li>
<li>Background
<ul>
<li><a href="https://gitlab.haskell.org/ghc/ghc/-/issues/26067">#26067: Please revise the release policy · Issues · Glasgow Haskell Compiler / GHC · GitLab</a></li>
<li><a href="https://discourse.haskell.org/t/please-revise-ghc-release-policy/12158">Please revise GHC release policy - Links - Haskell Community</a></li>
</ul></li>
</ul>
<p>Until now, GHC has followed a schedule of releasing a new major version every six months.
Bug fixes and other patches would typically be backported to around the three most recent branches (currently GHC 9.10, 9.12, and 9.14 — <a href="https://gitlab.haskell.org/ghc/ghc/-/wikis/GHC-status">see status</a>).</p>
<p>However, it usually takes time for a given major version to become stable through bug fixes, and for the ecosystem to catch up.
By the time a release feels “stable enough to use,” its support window is often already approaching its end.
For example, as of August 2025, GHCup recommends 9.6.7, but the 9.6 series itself is already out of support.</p>
<p>To address this, GHC will now designate some major versions as Long-Term Support (LTS) releases, aimed at users who want a stable version they can rely on for a longer period.
LTS releases will receive support for about 2–3 years. The first LTS release will be GHC 9.14.</p>
<h1 id="new-features-in-ghc-9.14">New Features in GHC 9.14</h1>
<h2 id="specialize-pragmas-can-now-take-expressions">SPECIALIZE pragmas can now take expressions</h2>
<ul>
<li><a href="https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0493-specialise-expressions.rst">Allow expressions in SPECIALISE pragmas - ghc-proposals/ghc-proposals</a></li>
</ul>
<p>In GHC, parametric polymorphism and type classes are implemented using type erasure and dictionary passing, which generally come with some runtime cost.
To generate efficient code, optimizations such as <strong>inlining</strong> and <strong>specialization</strong> are used.</p>
<p>To guide the compiler on inlining and specialization, we can use the <code>INLINE</code> pragma and the <code>SPECIALIZE</code> pragma.</p>
<p>Traditionally, the syntax for <code>SPECIALIZE</code> was:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# SPECIALIZE &lt;name&gt; :: &lt;type&gt; #-}</span></span></code></pre></div>
<p>For example, if you had <code>someFunc :: Monad m =&gt; m a -&gt; m b -&gt; m ([a], b)</code> and wanted to specialize it for <code>m = StateT Int IO</code>, you had to write:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# SPECIALIZE someFunc :: StateT Int IO a -&gt; State Int IO b -&gt; StateT Int IO ([a], b) #-}</span></span></code></pre></div>
<p>This gets cumbersome when the type you want to specialize appears multiple times—you have to repeat it everywhere.</p>
<p>Now, <code>SPECIALIZE</code> pragmas can take expressions.
In particular, with the help of the <code>TypeApplications</code> extension, the example above can be written as:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# SPECIALIZE someFunc @(StateT Int IO) #-}</span></span></code></pre></div>
<p>You can also specialize with respect to argument values.
For example:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">foo ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> [<span class="dt">Int</span>]</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>foo <span class="op">!</span>a <span class="ot">=</span> <span class="fu">map</span> (<span class="op">+</span> a)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# INLINE [0] foo #-}</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# SPECIALIZE foo 0 #-}</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="co">{- Equivalent to defining a rewrite rule: foo 0 = map (+ 0) -}</span></span></code></pre></div>
<p>Like rewrite rules, you can also use variables with <code>forall</code>.
For example, if you want to specialize on the second argument of:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">pow ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>pow _ <span class="dv">0</span> <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>pow x <span class="dv">1</span> <span class="ot">=</span> x</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>pow x n <span class="op">|</span> <span class="fu">even</span> n    <span class="ot">=</span> pow (x <span class="op">*</span> x) (n <span class="ot">`quot`</span> <span class="dv">2</span>)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> x <span class="op">*</span> pow (x <span class="op">*</span> x) (n <span class="ot">`quot`</span> <span class="dv">2</span>)</span></code></pre></div>
<p>you can write:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# SPECIALIZE forall x. pow x 1 #-}</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# SPECIALIZE forall x. pow x 2 #-}</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# SPECIALIZE forall x. pow x 3 #-}</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# SPECIALIZE forall x. pow x 4 #-}</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# SPECIALIZE forall x. pow x 5 #-}</span></span></code></pre></div>
<p>As an undocumented feature, it used to be possible to write multiple types in a comma-separated list:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# SPECIALIZE foo :: T1, T2 #-}</span></span></code></pre></div>
<p>But this form is scheduled for removal in GHC 9.18.</p>
<h2 id="wincomplete-record-selectors-is-now-enabled-by--wall"><code>-Wincomplete-record-selectors</code> is now enabled by <code>-Wall</code></h2>
<p>In GHC 9.10, the option <code>-Wincomplete-record-selectors</code> was introduced, which warns when a record selector that can fail is used. Starting with GHC 9.14, this option is now enabled as part of <code>-Wall</code>.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">T</span> <span class="ot">=</span> <span class="dt">A</span> {<span class="ot"> a ::</span> <span class="dt">Int</span> }</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>       <span class="op">|</span> <span class="dt">B</span> {<span class="ot"> b ::</span> <span class="dt">String</span> }</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> <span class="dt">T</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>f t <span class="ot">=</span> b t <span class="op">++</span> <span class="st">&quot;\n&quot;</span></span></code></pre></div>
<pre><code>$ ghc-9.14 -Wall recordsel.hs
recordsel.hs:5:7: warning: [GHC-17335] [-Wincomplete-record-selectors]
    Selecting the record field ‘b’ may fail for the following constructors:
      A
  |
5 | f t = b t ++ &quot;\n&quot;
  |       ^</code></pre>
<h2 id="changes-around-scopedtypevariables-typeapplications-and-typeabstractions">Changes around ScopedTypeVariables, TypeApplications, and TypeAbstractions</h2>
<p>Previously, when both the <code>ScopedTypeVariables</code> and <code>TypeApplications</code> extensions were enabled, it was possible to write type bindings directly in patterns. For example, the following code compiles in GHC 9.12:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeApplications #-}</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">T</span> a <span class="ot">=</span> <span class="dt">MkT</span> a</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> <span class="kw">forall</span> a<span class="op">.</span> <span class="dt">T</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>f t <span class="ot">=</span> <span class="kw">case</span> t <span class="kw">of</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">MkT</span> <span class="op">@</span>a2 x <span class="ot">-&gt;</span> x</span></code></pre></div>
<p>Starting with GHC 9.14, such code now requires the <code>TypeAbstractions</code> extension to be enabled.</p>
<h2 id="changes-in-desugaring-for-overloadedrecordupdate">Changes in desugaring for OverloadedRecordUpdate</h2>
<ul>
<li><a href="https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0583-hasfield-redesign.rst">HasField redesign - ghc-proposals/ghc-proposals</a></li>
</ul>
<p>In connection with Haskell’s record-related extensions, there is a class called <code>HasField</code>:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">GHC.Records</span> <span class="kw">where</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">HasField</span> x r a <span class="op">|</span> x r <span class="ot">-&gt;</span> a <span class="kw">where</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  getField ::</span> r <span class="ot">-&gt;</span> a</span></code></pre></div>
<p>Combined with the <code>DuplicateRecordFields</code> extension, this allows you to work with different records that share the same field name (via the <code>getField</code> function):</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DuplicateRecordFields #-}</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DataKinds #-}</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.Records</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">S</span> <span class="ot">=</span> <span class="dt">S</span> {<span class="ot"> foo ::</span> <span class="dt">Int</span> }</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">T</span> <span class="ot">=</span> <span class="dt">T</span> {<span class="ot"> foo ::</span> <span class="dt">String</span> }</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="op">$</span> getField <span class="op">@</span><span class="st">&quot;foo&quot;</span> (<span class="dt">S</span> <span class="dv">42</span>)</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> <span class="op">$</span> getField <span class="op">@</span><span class="st">&quot;foo&quot;</span> (<span class="dt">T</span> <span class="st">&quot;Hello&quot;</span>)</span></code></pre></div>
<p>Currently, the <code>HasField</code> class only supports retrieving record fields.
There is a plan to extend this so that fields can also be updated.</p>
<p>Originally, the idea was to add a <code>setField</code> function with the following type:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ot">setField ::</span> <span class="kw">forall</span> x r a<span class="op">.</span> <span class="dt">HasField</span> x r a <span class="ot">=&gt;</span> r <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> r</span></code></pre></div>
<p>Indeed, in GHC 9.2, Record Dot Syntax was implemented to desugar into <code>setField</code> of this form.</p>
<p>Under the new plan, the argument order of <code>setField</code> changes to:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">SetField</span> x r a <span class="op">|</span> x r <span class="ot">-&gt;</span> a <span class="kw">where</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  setField ::</span> a <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> r</span></code></pre></div>
<p>In other words, the field value now comes first, followed by the record.</p>
<p>With this new argument order in mind, examples using <code>OverloadedRecordDot</code> would look like this:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE CPP #-}</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE AllowAmbiguousTypes #-}</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DataKinds #-}</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE FunctionalDependencies #-}</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedRecordDot #-}</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedRecordUpdate #-}</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE RebindableSyntax #-}</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Prelude</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.Records</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Foo</span> <span class="ot">=</span> <span class="dt">Foo</span> {<span class="ot"> x ::</span> <span class="dt">Int</span> } <span class="kw">deriving</span> <span class="dt">Show</span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Bar</span> <span class="ot">=</span> <span class="dt">Bar</span> {<span class="ot"> foo ::</span> <span class="dt">Foo</span></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>               ,<span class="ot"> y ::</span> <span class="dt">String</span></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>               } <span class="kw">deriving</span> <span class="dt">Show</span></span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">HasField&#39;</span> x r a <span class="op">|</span> x r <span class="ot">-&gt;</span> a <span class="kw">where</span></span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a><span class="pp">#if MIN_VERSION_GLASGOW_HASKELL(9, 14, 0, 0)</span></span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a><span class="ot">  setField ::</span> a <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> r</span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a><span class="pp">#else</span></span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a><span class="ot">  setField ::</span> r <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> r</span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span>
<span id="cb16-23"><a href="#cb16-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-24"><a href="#cb16-24" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">HasField&#39;</span> <span class="st">&quot;x&quot;</span> <span class="dt">Foo</span> <span class="dt">Int</span> <span class="kw">where</span></span>
<span id="cb16-25"><a href="#cb16-25" aria-hidden="true" tabindex="-1"></a><span class="pp">#if MIN_VERSION_GLASGOW_HASKELL(9, 14, 0, 0)</span></span>
<span id="cb16-26"><a href="#cb16-26" aria-hidden="true" tabindex="-1"></a>  setField x _ <span class="ot">=</span> <span class="dt">Foo</span> x</span>
<span id="cb16-27"><a href="#cb16-27" aria-hidden="true" tabindex="-1"></a><span class="pp">#else</span></span>
<span id="cb16-28"><a href="#cb16-28" aria-hidden="true" tabindex="-1"></a>  setField _ x <span class="ot">=</span> <span class="dt">Foo</span> x</span>
<span id="cb16-29"><a href="#cb16-29" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span>
<span id="cb16-30"><a href="#cb16-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-31"><a href="#cb16-31" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">HasField&#39;</span> <span class="st">&quot;foo&quot;</span> <span class="dt">Bar</span> <span class="dt">Foo</span> <span class="kw">where</span></span>
<span id="cb16-32"><a href="#cb16-32" aria-hidden="true" tabindex="-1"></a><span class="pp">#if MIN_VERSION_GLASGOW_HASKELL(9, 14, 0, 0)</span></span>
<span id="cb16-33"><a href="#cb16-33" aria-hidden="true" tabindex="-1"></a>  setField foo <span class="dt">Bar</span> { foo <span class="ot">=</span> _, y <span class="ot">=</span> y } <span class="ot">=</span> <span class="dt">Bar</span> { foo <span class="ot">=</span> foo, y <span class="ot">=</span> y }</span>
<span id="cb16-34"><a href="#cb16-34" aria-hidden="true" tabindex="-1"></a><span class="pp">#else</span></span>
<span id="cb16-35"><a href="#cb16-35" aria-hidden="true" tabindex="-1"></a>  setField <span class="dt">Bar</span> { foo <span class="ot">=</span> _, y <span class="ot">=</span> y } foo <span class="ot">=</span> <span class="dt">Bar</span> { foo <span class="ot">=</span> foo, y <span class="ot">=</span> y }</span>
<span id="cb16-36"><a href="#cb16-36" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span>
<span id="cb16-37"><a href="#cb16-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-38"><a href="#cb16-38" aria-hidden="true" tabindex="-1"></a>u <span class="ot">=</span> <span class="dt">Bar</span> { foo <span class="ot">=</span> <span class="dt">Foo</span> { x <span class="ot">=</span> <span class="dv">42</span> }, y <span class="ot">=</span> <span class="st">&quot;Hello!&quot;</span> }</span>
<span id="cb16-39"><a href="#cb16-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-40"><a href="#cb16-40" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> (u { foo<span class="op">.</span>x <span class="ot">=</span> <span class="dv">37</span> })</span></code></pre></div>
<h2 id="allowing-multilinestrings-in-foreign-import">Allowing MultilineStrings in <code>foreign import</code></h2>
<ul>
<li><a href="https://gitlab.haskell.org/ghc/ghc/-/issues/25157">#25157: Support multiline strings in foreign import · Issues · Glasgow Haskell Compiler / GHC · GitLab</a></li>
</ul>
<p>You can now use multiline string literals (via the <code>MultilineStrings</code> extension) in <code>foreign import</code> declarations.
This should be especially handy for JavaScript FFI.</p>
<p>Here’s an example from the issue:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>foreign <span class="kw">import</span> javascript</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;&quot;&quot;</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="st">  (() =&gt; {</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="st">    console.log(&quot;</span>hello<span class="st">&quot;);</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="st">    console.log(1 + 1);</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a><span class="st">  })</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a><span class="st">  &quot;&quot;&quot;</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a><span class="ot">  action ::</span> <span class="dt">IO</span> ()</span></code></pre></div>
<h2 id="coerce-and-type-defaulting"><code>coerce</code> and Type Defaulting</h2>
<ul>
<li><a href="https://gitlab.haskell.org/ghc/ghc/-/issues/21003">#21003: Coercible constraints should be picked arbitrarily · Issues · Glasgow Haskell Compiler / GHC · GitLab</a></li>
</ul>
<p>Ambiguous types involving the <code>coerce</code> function or the <code>Coercible</code> class are now resolved more aggressively.
For example, the following program would trigger a type ambiguity error in GHC 9.12, but it compiles successfully in GHC 9.14:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Coerce</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> <span class="op">$</span> coerce (<span class="dv">42</span><span class="ot"> ::</span> <span class="dt">Int</span>)</span></code></pre></div>
<pre><code>$ runghc-9.12 coerce.hs
coerce.hs:4:16: error: [GHC-10283]
    • Couldn&#39;t match representation of type ‘a0’ with that of ‘Int’
        arising from a use of ‘coerce’
    • In the second argument of ‘($)’, namely ‘coerce (42 :: Int)’
      In the expression: print $ coerce (42 :: Int)
      In an equation for ‘main’: main = print $ coerce (42 :: Int)
  |
4 | main = print $ coerce (42 :: Int)
  |                ^^^^^^

$ runghc-9.14 coerce.hs
42</code></pre>
<h2 id="specifying-record-field-multiplicity-under-the-lineartypes-extension">Specifying Record Field Multiplicity under the <code>LinearTypes</code> Extension</h2>
<ul>
<li><a href="https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0111-linear-types.rst#records-and-projections">ghc-proposals/proposals/0111-linear-types.rst at master · ghc-proposals/ghc-proposals</a></li>
<li><a href="https://gitlab.haskell.org/ghc/ghc/-/issues/18462">#18462: Linear types syntax: multiplicity annotation on records · Issues · Glasgow Haskell Compiler / GHC · GitLab</a></li>
</ul>
<p>With the <code>LinearTypes</code> extension, you can now specify the multiplicity of record fields.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE LinearTypes #-}</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.Exts</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">A</span> <span class="ot">=</span> <span class="dt">MkA</span> <span class="dt">Int</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">B</span> <span class="kw">where</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">MkB</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">B</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">C</span> <span class="kw">where</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>  <span class="dt">MkC</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="op">%</span><span class="dt">&#39;Many</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="op">%</span><span class="dt">&#39;One</span> <span class="ot">-&gt;</span> <span class="dt">C</span></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a><span class="co">-- New feature in GHC 9.14</span></span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">R</span> <span class="ot">=</span> <span class="dt">R</span> { foo <span class="op">%</span><span class="dt">&#39;Many</span><span class="ot"> ::</span> <span class="dt">Int</span>, bar <span class="op">%</span><span class="dt">&#39;One</span><span class="ot"> ::</span> <span class="dt">Int</span> }</span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a><span class="ot">fA ::</span> <span class="dt">A</span> <span class="op">%</span><span class="dv">1</span><span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a>fA (<span class="dt">MkA</span> x) <span class="ot">=</span> x</span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a><span class="ot">fB ::</span> <span class="dt">B</span> <span class="op">%</span><span class="dv">1</span><span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a>fB (<span class="dt">MkB</span> x) <span class="ot">=</span> x</span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true" tabindex="-1"></a><span class="co">-- Error (y is discarded)</span></span>
<span id="cb20-22"><a href="#cb20-22" aria-hidden="true" tabindex="-1"></a><span class="co">-- fC1 :: C %1-&gt; Int</span></span>
<span id="cb20-23"><a href="#cb20-23" aria-hidden="true" tabindex="-1"></a><span class="co">-- fC1 (MkC x y) = x</span></span>
<span id="cb20-24"><a href="#cb20-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-25"><a href="#cb20-25" aria-hidden="true" tabindex="-1"></a><span class="ot">fC2 ::</span> <span class="dt">C</span> <span class="op">%</span><span class="dv">1</span><span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb20-26"><a href="#cb20-26" aria-hidden="true" tabindex="-1"></a>fC2 (<span class="dt">MkC</span> x y) <span class="ot">=</span> y</span>
<span id="cb20-27"><a href="#cb20-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-28"><a href="#cb20-28" aria-hidden="true" tabindex="-1"></a><span class="co">-- Error (bar is discarded)</span></span>
<span id="cb20-29"><a href="#cb20-29" aria-hidden="true" tabindex="-1"></a><span class="co">-- fR1 :: R %1 -&gt; Int</span></span>
<span id="cb20-30"><a href="#cb20-30" aria-hidden="true" tabindex="-1"></a><span class="co">-- fR1 (R { foo, bar }) = foo</span></span>
<span id="cb20-31"><a href="#cb20-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-32"><a href="#cb20-32" aria-hidden="true" tabindex="-1"></a><span class="ot">fR2 ::</span> <span class="dt">R</span> <span class="op">%</span><span class="dv">1</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb20-33"><a href="#cb20-33" aria-hidden="true" tabindex="-1"></a>fR2 (<span class="dt">R</span> { foo, bar }) <span class="ot">=</span> bar</span>
<span id="cb20-34"><a href="#cb20-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-35"><a href="#cb20-35" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb20-36"><a href="#cb20-36" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">pure</span> ()</span></code></pre></div>
<h2 id="you-can-now-use-data-with-the-explicitnamespaces-extension">You can now use <code>data</code> with the <code>ExplicitNamespaces</code> extension</h2>
<ul>
<li><a href="https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0581-namespace-specified-imports.rst">Namespace-specified imports - ghc-proposals/ghc-proposals</a></li>
</ul>
<p>Haskell has separate namespaces for types and for data (terms).
Here’s an artificial example: the code below defines <code>T :: Type</code> and <code>U :: Type -&gt; Type</code> in the type namespace, and <code>U :: Int -&gt; T</code> and <code>T :: a -&gt; U a</code> in the data namespace:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">T</span> <span class="ot">=</span> <span class="dt">U</span> <span class="dt">Int</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">U</span> a <span class="ot">=</span> <span class="dt">T</span> a</span></code></pre></div>
<p>However, the boundary between type and data namespaces is becoming more blurred with extensions like <code>DataKinds</code> and <code>RequiredTypeArguments</code>.
It’s ideal to avoid ambiguity by giving types and data different names, but there is already a lot of existing code that uses the same name for both, such as the <code>Proxy</code> type:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Proxy</span> a <span class="ot">=</span> <span class="dt">Proxy</span></span></code></pre></div>
<p>With the <code>ExplicitNamespaces</code> extension, you can choose to import only types.
Moreover, with the <code>PatternSynonyms</code> extension, you can select only the data constructors:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- This works in older GHC versions too (e.g., 9.12)</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DataKinds #-}</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE ExplicitNamespaces #-}</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE PatternSynonyms #-}</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Proxy</span> <span class="kw">as</span> <span class="dt">PT</span> (type <span class="dt">Proxy</span>)</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Proxy</span> <span class="kw">as</span> <span class="dt">PD</span> (pattern <span class="dt">Proxy</span>)</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> (<span class="dt">PD.Proxy</span><span class="ot"> ::</span> <span class="dt">PT.Proxy</span> <span class="dt">PD.Proxy</span>)</span></code></pre></div>
<p>However, writing <code>pattern</code> just to import data constructors feels a bit unnatural.
In GHC 9.14, <code>ExplicitNamespaces</code> has been extended so that you can now use <code>data</code> to import data constructors:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DataKinds #-}</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE ExplicitNamespaces #-}</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Proxy</span> <span class="kw">as</span> <span class="dt">PT</span> (type <span class="dt">Proxy</span>)</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Proxy</span> <span class="kw">as</span> <span class="dt">PD</span> (data <span class="dt">Proxy</span>)</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> (<span class="dt">PD.Proxy</span><span class="ot"> ::</span> <span class="dt">PT.Proxy</span> <span class="dt">PD.Proxy</span>)</span></code></pre></div>
<p>In the future, you’ll be able to import everything from either the type or data namespace using double dots <code>..</code>, but this is not implemented in GHC 9.14 yet (<a href="https://gitlab.haskell.org/ghc/ghc/-/issues/25901">#25901</a>):</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Not yet available in GHC 9.14</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DataKinds #-}</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE ExplicitNamespaces #-}</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Proxy</span> <span class="kw">as</span> <span class="dt">PT</span> (type ..)</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Proxy</span> <span class="kw">as</span> <span class="dt">PD</span> (data ..)</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> (<span class="dt">PD.Proxy</span><span class="ot"> ::</span> <span class="dt">PT.Proxy</span> <span class="dt">PD.Proxy</span>)</span></code></pre></div>
<p>As a side effect, using <code>pattern</code> in import/export lists is now deprecated (though it’s not planned to be removed).
GHC 9.14 introduces a new warning option, <code>-Wpattern-namespace-specifier</code> (included in <code>-Wcompat</code>), which triggers a warning when <code>pattern</code> is used in import/export lists.</p>
<h2 id="bug-fix-using-a-data-type-in-a-kind-without-datakinds-no-longer-allowed">Bug fix: using a data type in a kind without <code>DataKinds</code> no longer allowed</h2>
<ul>
<li><a href="https://gitlab.haskell.org/ghc/ghc/-/issues/22141">#22141: GHC-9.4 accepts “data” in kinds without DataKinds · Issues · Glasgow Haskell Compiler / GHC · GitLab</a></li>
</ul>
<p>The following code uses the data type <code>Nat</code> as a kind, so the <code>DataKinds</code> extension is required.
However, starting with GHC 9.4, it was incorrectly accepted even without <code>DataKinds</code>:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Kind</span> (<span class="dt">Type</span>)</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.TypeNats</span> (<span class="dt">Nat</span>)</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">T</span><span class="ot"> ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">T</span> a <span class="ot">=</span> <span class="dt">T</span></span></code></pre></div>
<p>This bug has now been fixed.</p>
<h2 id="the-monadcomprehensions-extension-now-implies-parallellistcomp">The <code>MonadComprehensions</code> extension now implies <code>ParallelListComp</code></h2>
<ul>
<li><a href="https://gitlab.haskell.org/ghc/ghc/-/issues/25645">#25645: MonadComprehensions does not imply ParallelListComp? · Issues · Glasgow Haskell Compiler / GHC · GitLab</a></li>
</ul>
<p>The <code>MonadComprehensions</code> extension was <a href="https://downloads.haskell.org/ghc/9.12.2/docs/users_guide/exts/monad_comprehensions.html#extension-MonadComprehensions">documented</a> to imply <code>ParallelListComp</code>, but in practice it did not.</p>
<p>Starting with GHC 9.14, the following code now compiles:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE MonadComprehensions #-}</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> [(x,y) <span class="op">|</span> x <span class="ot">&lt;-</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>] <span class="op">|</span> y <span class="ot">&lt;-</span> [<span class="st">&quot;Alpha&quot;</span>,<span class="st">&quot;Bravo&quot;</span>,<span class="st">&quot;Charlie&quot;</span>]]</span></code></pre></div>
<h2 id="you-can-now-use-visible-forall-in-data-constructors">You can now use visible <code>forall</code> in data constructors</h2>
<ul>
<li><a href="https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0281-visible-forall.rst">ghc-proposals/proposals/0281-visible-forall.rst at master · ghc-proposals/ghc-proposals</a></li>
<li><a href="https://gitlab.haskell.org/ghc/ghc/-/issues/25127">#25127: Visible forall in GADTs · Issues · Glasgow Haskell Compiler / GHC · GitLab</a></li>
<li><a href="https://downloads.haskell.org/ghc/9.14.0.20250819/docs/users_guide/exts/required_type_arguments.html#visible-forall-in-gadts">6.4.19. Required type arguments — Glasgow Haskell Compiler 9.14.0.20250819 User’s Guide</a></li>
</ul>
<p>GADTs now support visible <code>forall</code> (i.e., <code>forall a -&gt;</code>).
The <code>ProxyList'</code> type from the previously written article <a href="./2024-05-11-playing-with-visible-forall.md">Playing with Visible Forall in GHC 9.10</a> can now be rewritten as follows:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE RequiredTypeArguments #-}</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">ProxyList</span><span class="ot"> ::</span> [k] <span class="ot">-&gt;</span> <span class="dt">Type</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">ProxyList</span> xs <span class="kw">where</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">PNil</span><span class="ot"> ::</span> <span class="dt">ProxyList</span> &#39;[]</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">PCons</span><span class="ot"> ::</span> <span class="kw">forall</span> x <span class="ot">-&gt;</span> <span class="kw">forall</span> xs <span class="ot">-&gt;</span> <span class="dt">ProxyListI</span> xs <span class="ot">=&gt;</span> <span class="dt">ProxyList</span> (x <span class="op">:</span> xs)</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">ProxyListI</span> xs <span class="kw">where</span></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a><span class="ot">  proxyList ::</span> <span class="dt">ProxyList</span> xs</span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">ProxyListI</span> &#39;[] <span class="kw">where</span></span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a>  proxyList <span class="ot">=</span> <span class="dt">PNil</span></span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">ProxyListI</span> xs <span class="ot">=&gt;</span> <span class="dt">ProxyListI</span> (x <span class="op">:</span> xs) <span class="kw">where</span></span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a>  proxyList <span class="ot">=</span> <span class="dt">PCons</span> x xs</span></code></pre></div>
<h2 id="expanded-simd-support-in-the-x86-ncg-backend">Expanded SIMD Support in the x86 NCG Backend</h2>
<ul>
<li><a href="https://gitlab.haskell.org/ghc/ghc/-/issues/25487">#25487: x86 NCG SIMD: Implement pack/insert/broadcast/unpack for integer vectors · Issues · Glasgow Haskell Compiler / GHC · GitLab</a></li>
<li><a href="https://gitlab.haskell.org/ghc/ghc/-/issues/25643">#25643: x86 NCG SIMD: Implement arithmetic operations for integer vectors · Issues · Glasgow Haskell Compiler / GHC · GitLab</a></li>
<li><a href="https://gitlab.haskell.org/ghc/ghc/-/issues/26096">#26096: Better lowering for shuffleFloatX4# and shuffleDoubleX2# · Issues · Glasgow Haskell Compiler / GHC · GitLab</a></li>
</ul>
<p>SIMD (Single Instruction, Multiple Data) allows you to process multiple data elements with a single instruction, which is useful for writing high-performance code on modern CPUs.
GHC provides data types and primops for SIMD.</p>
<p>Until recently, GHC’s SIMD primitives were only available with the LLVM backend.
Progress has been made: in GHC 9.12, some SIMD types and operations became available on the x86 NCG backend.</p>
<p>In GHC 9.14, the set of types and operations supported on x86 NCG has expanded.
In addition, shuffling floating-point vectors no longer requires <code>-mavx</code> on x86 NCG (it was required in GHC 9.12).</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE MagicHash #-}</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE UnboxedTuples #-}</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.Prim</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.Exts</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.Int</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">FloatX4</span> <span class="ot">=</span> <span class="dt">FloatX4</span> <span class="dt">FloatX4</span><span class="op">#</span></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a><span class="ot">packFloatX4 ::</span> (<span class="dt">Float</span>, <span class="dt">Float</span>, <span class="dt">Float</span>, <span class="dt">Float</span>) <span class="ot">-&gt;</span> <span class="dt">FloatX4</span></span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a>packFloatX4 (<span class="dt">F</span><span class="op">#</span> x0, <span class="dt">F</span><span class="op">#</span> x1, <span class="dt">F</span><span class="op">#</span> x2, <span class="dt">F</span><span class="op">#</span> x3) <span class="ot">=</span> <span class="dt">FloatX4</span> (packFloatX4<span class="op">#</span> (<span class="op">#</span> x0, x1, x2, x3 <span class="op">#</span>))</span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a><span class="ot">unpackFloatX4 ::</span> <span class="dt">FloatX4</span> <span class="ot">-&gt;</span> (<span class="dt">Float</span>, <span class="dt">Float</span>, <span class="dt">Float</span>, <span class="dt">Float</span>)</span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true" tabindex="-1"></a>unpackFloatX4 (<span class="dt">FloatX4</span> v) <span class="ot">=</span> <span class="kw">case</span> unpackFloatX4<span class="op">#</span> v <span class="kw">of</span> (<span class="op">#</span> x0, x1, x2, x3 <span class="op">#</span>) <span class="ot">-&gt;</span> (<span class="dt">F</span><span class="op">#</span> x0, <span class="dt">F</span><span class="op">#</span> x1, <span class="dt">F</span><span class="op">#</span> x2, <span class="dt">F</span><span class="op">#</span> x3)</span>
<span id="cb29-14"><a href="#cb29-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-15"><a href="#cb29-15" aria-hidden="true" tabindex="-1"></a><span class="ot">plusFloatX4 ::</span> <span class="dt">FloatX4</span> <span class="ot">-&gt;</span> <span class="dt">FloatX4</span> <span class="ot">-&gt;</span> <span class="dt">FloatX4</span></span>
<span id="cb29-16"><a href="#cb29-16" aria-hidden="true" tabindex="-1"></a>plusFloatX4 (<span class="dt">FloatX4</span> u) (<span class="dt">FloatX4</span> v) <span class="ot">=</span> <span class="dt">FloatX4</span> (plusFloatX4<span class="op">#</span> u v)</span>
<span id="cb29-17"><a href="#cb29-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-18"><a href="#cb29-18" aria-hidden="true" tabindex="-1"></a><span class="co">-- In GHC 9.14, shuffleFloatX4# works without -mavx</span></span>
<span id="cb29-19"><a href="#cb29-19" aria-hidden="true" tabindex="-1"></a><span class="ot">reverseFloatX4 ::</span> <span class="dt">FloatX4</span> <span class="ot">-&gt;</span> <span class="dt">FloatX4</span></span>
<span id="cb29-20"><a href="#cb29-20" aria-hidden="true" tabindex="-1"></a>reverseFloatX4 (<span class="dt">FloatX4</span> v) <span class="ot">=</span> <span class="dt">FloatX4</span> (shuffleFloatX4<span class="op">#</span> v v (<span class="op">#</span> <span class="dv">3</span><span class="op">#</span>, <span class="dv">2</span><span class="op">#</span>, <span class="dv">1</span><span class="op">#</span>, <span class="dv">0</span><span class="op">#</span> <span class="op">#</span>))</span>
<span id="cb29-21"><a href="#cb29-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-22"><a href="#cb29-22" aria-hidden="true" tabindex="-1"></a><span class="co">-- In GHC 9.14, Int32X4# and similar are available on x86 NCG</span></span>
<span id="cb29-23"><a href="#cb29-23" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Int32X4</span> <span class="ot">=</span> <span class="dt">Int32X4</span> <span class="dt">Int32X4</span><span class="op">#</span></span>
<span id="cb29-24"><a href="#cb29-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-25"><a href="#cb29-25" aria-hidden="true" tabindex="-1"></a><span class="ot">packInt32X4 ::</span> (<span class="dt">Int32</span>, <span class="dt">Int32</span>, <span class="dt">Int32</span>, <span class="dt">Int32</span>) <span class="ot">-&gt;</span> <span class="dt">Int32X4</span></span>
<span id="cb29-26"><a href="#cb29-26" aria-hidden="true" tabindex="-1"></a>packInt32X4 (<span class="dt">I32</span><span class="op">#</span> x0, <span class="dt">I32</span><span class="op">#</span> x1, <span class="dt">I32</span><span class="op">#</span> x2, <span class="dt">I32</span><span class="op">#</span> x3) <span class="ot">=</span> <span class="dt">Int32X4</span> (packInt32X4<span class="op">#</span> (<span class="op">#</span> x0, x1, x2, x3 <span class="op">#</span>))</span>
<span id="cb29-27"><a href="#cb29-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-28"><a href="#cb29-28" aria-hidden="true" tabindex="-1"></a><span class="ot">unpackInt32X4 ::</span> <span class="dt">Int32X4</span> <span class="ot">-&gt;</span> (<span class="dt">Int32</span>, <span class="dt">Int32</span>, <span class="dt">Int32</span>, <span class="dt">Int32</span>)</span>
<span id="cb29-29"><a href="#cb29-29" aria-hidden="true" tabindex="-1"></a>unpackInt32X4 (<span class="dt">Int32X4</span> v) <span class="ot">=</span> <span class="kw">case</span> unpackInt32X4<span class="op">#</span> v <span class="kw">of</span> (<span class="op">#</span> x0, x1, x2, x3 <span class="op">#</span>) <span class="ot">-&gt;</span> (<span class="dt">I32</span><span class="op">#</span> x0, <span class="dt">I32</span><span class="op">#</span> x1, <span class="dt">I32</span><span class="op">#</span> x2, <span class="dt">I32</span><span class="op">#</span> x3)</span>
<span id="cb29-30"><a href="#cb29-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-31"><a href="#cb29-31" aria-hidden="true" tabindex="-1"></a><span class="ot">plusInt32X4 ::</span> <span class="dt">Int32X4</span> <span class="ot">-&gt;</span> <span class="dt">Int32X4</span> <span class="ot">-&gt;</span> <span class="dt">Int32X4</span></span>
<span id="cb29-32"><a href="#cb29-32" aria-hidden="true" tabindex="-1"></a>plusInt32X4 (<span class="dt">Int32X4</span> u) (<span class="dt">Int32X4</span> v) <span class="ot">=</span> <span class="dt">Int32X4</span> (plusInt32X4<span class="op">#</span> u v)</span>
<span id="cb29-33"><a href="#cb29-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-34"><a href="#cb29-34" aria-hidden="true" tabindex="-1"></a><span class="ot">reverseInt32X4 ::</span> <span class="dt">Int32X4</span> <span class="ot">-&gt;</span> <span class="dt">Int32X4</span></span>
<span id="cb29-35"><a href="#cb29-35" aria-hidden="true" tabindex="-1"></a>reverseInt32X4 (<span class="dt">Int32X4</span> v) <span class="ot">=</span> <span class="dt">Int32X4</span> (shuffleInt32X4<span class="op">#</span> v v (<span class="op">#</span> <span class="dv">3</span><span class="op">#</span>, <span class="dv">2</span><span class="op">#</span>, <span class="dv">1</span><span class="op">#</span>, <span class="dv">0</span><span class="op">#</span> <span class="op">#</span>))</span>
<span id="cb29-36"><a href="#cb29-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-37"><a href="#cb29-37" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb29-38"><a href="#cb29-38" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb29-39"><a href="#cb29-39" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> a <span class="ot">=</span> packFloatX4 (<span class="fl">1.0</span>, <span class="fl">2.0</span>, <span class="fl">3.0</span>, <span class="fl">4.0</span>)</span>
<span id="cb29-40"><a href="#cb29-40" aria-hidden="true" tabindex="-1"></a>      b <span class="ot">=</span> packFloatX4 (<span class="fl">0.1</span>, <span class="fl">0.2</span>, <span class="fl">0.3</span>, <span class="fl">0.4</span>)</span>
<span id="cb29-41"><a href="#cb29-41" aria-hidden="true" tabindex="-1"></a>      c <span class="ot">=</span> plusFloatX4 a b</span>
<span id="cb29-42"><a href="#cb29-42" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> (unpackFloatX4 c)</span>
<span id="cb29-43"><a href="#cb29-43" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> (unpackFloatX4 (reverseFloatX4 c))</span>
<span id="cb29-44"><a href="#cb29-44" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> d <span class="ot">=</span> packInt32X4 (<span class="dv">10</span>, <span class="dv">20</span>, <span class="dv">30</span>, <span class="dv">40</span>)</span>
<span id="cb29-45"><a href="#cb29-45" aria-hidden="true" tabindex="-1"></a>      e <span class="ot">=</span> packInt32X4 (<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>)</span>
<span id="cb29-46"><a href="#cb29-46" aria-hidden="true" tabindex="-1"></a>      f <span class="ot">=</span> plusInt32X4 d e</span>
<span id="cb29-47"><a href="#cb29-47" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> (unpackInt32X4 f)</span>
<span id="cb29-48"><a href="#cb29-48" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> (unpackInt32X4 (reverseInt32X4 f))</span></code></pre></div>
<p>At this stage, the vector width supported on x86 NCG is still limited to 128 bits.</p>
<h2 id="ghci-now-supports-multiple-home-units">GHCi Now Supports Multiple Home Units</h2>
<ul>
<li><a href="https://well-typed.com/blog/2025/06/ghci-multiple-home-units/">Making GHCi compatible with multiple home units - Well-Typed: The Haskell Consultants</a></li>
<li><a href="https://gitlab.haskell.org/ghc/ghc/-/issues/20889">#20889: MHU: Most of GHCi commands do not work · Issues · Glasgow Haskell Compiler / GHC · GitLab</a></li>
</ul>
<p>GHCi can now handle projects composed of multiple units (libraries and executables) more effectively.
I don’t fully understand all the internals yet, so I’ll demonstrate by experimenting.</p>
<p>First, create a sample project:</p>
<pre><code>$ mkdir mhu-example &amp;&amp; cd mhu-example
$ cabal init -n --tests --libandexe -d &quot;base &gt;=4.19 &amp;&amp; &lt;4.23&quot;</code></pre>
<p>Now, try running it in the REPL:</p>
<pre><code>$ cabal repl -w ghc-9.12 exe:mhu-example
Resolving dependencies...
Build profile: -w ghc-9.12.2 -O1
In order, the following will be built (use -v for more details):
 - mhu-example-0.1.0.0 (lib) (configuration changed)
 - mhu-example-0.1.0.0 (interactive) (exe:mhu-example) (configuration changed)
Configuring library for mhu-example-0.1.0.0...
Preprocessing library for mhu-example-0.1.0.0...
Building library for mhu-example-0.1.0.0...
[1 of 1] Compiling MyLib            ( src/MyLib.hs, dist-newstyle/build/x86_64-osx/ghc-9.12.2/mhu-example-0.1.0.0/build/MyLib.o, dist-newstyle/build/x86_64-osx/ghc-9.12.2/mhu-example-0.1.0.0/build/MyLib.dyn_o )
Configuring executable &#39;mhu-example&#39; for mhu-example-0.1.0.0...
Preprocessing executable &#39;mhu-example&#39; for mhu-example-0.1.0.0...
GHCi, version 9.12.2: https://www.haskell.org/ghc/  :? for help
[1 of 2] Compiling Main             ( app/Main.hs, interpreted )
Ok, one module loaded.
ghci&gt; main
Hello, Haskell!
someFunc
ghci&gt;</code></pre>
<p>Looks good.</p>
<p>While keeping the REPL open, modify <code>src/MyLib.hs</code> as follows:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">MyLib</span> (someFunc) <span class="kw">where</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a><span class="ot">someFunc ::</span> <span class="dt">IO</span> ()</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>someFunc <span class="ot">=</span> <span class="fu">putStrLn</span> <span class="st">&quot;someFunc, revised&quot;</span></span></code></pre></div>
<p>Reload in GHCi (<code>:r</code>) and run again—the output <strong>does not change</strong>:</p>
<pre><code>ghci&gt; :r
Ok, one module reloaded.
ghci&gt; main
Hello, Haskell!
someFunc</code></pre>
<p>The linked article explains this in detail, but this illustrates the limitation of older GHC versions.</p>
<p>Now, try GHC 9.14 with <code>--enable-multi-repl</code>, also specifying the library <code>lib:mhu-example</code> to Cabal:</p>
<pre><code>$ cabal repl -w ghc-9.14 --enable-multi-repl exe:mhu-example lib:mhu-example
Resolving dependencies...
Build profile: -w ghc-9.14.0.20250819 -O1
In order, the following will be built (use -v for more details):
 - mhu-example-0.1.0.0 (interactive) (lib) (configuration changed)
 - mhu-example-0.1.0.0 (interactive) (exe:mhu-example) (configuration changed)
Configuring library for mhu-example-0.1.0.0...
Preprocessing library for mhu-example-0.1.0.0...
Configuring executable &#39;mhu-example&#39; for mhu-example-0.1.0.0...
Preprocessing executable &#39;mhu-example&#39; for mhu-example-0.1.0.0...
GHCi, version 9.14.0.20250819: https://www.haskell.org/ghc/  :? for help
[1 of 3] Compiling MyLib            ( src/MyLib.hs, interpreted )[mhu-example-0.1.0.0-inplace]
[2 of 3] Compiling Main             ( app/Main.hs, interpreted )[mhu-example-0.1.0.0-inplace-mhu-example]
Ok, two modules loaded.
ghci&gt; Main.main
Hello, Haskell!
someFunc, revised</code></pre>
<p>Great.</p>
<p>Now, while keeping the REPL open, modify <code>src/MyLib.hs</code> again:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">MyLib</span> (someFunc) <span class="kw">where</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a><span class="ot">someFunc ::</span> <span class="dt">IO</span> ()</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>someFunc <span class="ot">=</span> <span class="fu">putStrLn</span> <span class="st">&quot;someFunc, revised^2&quot;</span></span></code></pre></div>
<p>Reloading the REPL now <strong>reflects changes to the library</strong>:</p>
<pre><code>ghci&gt; :r
[1 of 3] Compiling MyLib            ( src/MyLib.hs, interpreted )[mhu-example-0.1.0.0-inplace] [Source file changed]
Ok, two modules reloaded.
ghci&gt; Main.main
Hello, Haskell!
someFunc, revised^2</code></pre>
<h2 id="libraries">Libraries</h2>
<p>We also cover changes to libraries, mainly the <code>base</code> package.</p>
<h3 id="fail-now-includes-hascallstack"><code>fail</code> Now Includes <code>HasCallStack</code></h3>
<ul>
<li><a href="https://github.com/haskell/core-libraries-committee/issues/327">Add HasCallStack to Control.Monad.fail · Issue #327 · haskell/core-libraries-committee</a></li>
</ul>
<p><code>HasCallStack</code> is a lightweight mechanism for capturing stack traces.
Attaching it to functions that may fail (i.e., functions that may call <code>error</code>) helps with debugging.</p>
<p>In GHC 9.14, the <code>fail</code> function in the <code>MonadFail</code> class now has <code>HasCallStack</code>.
The <code>fail</code> function is called when a pattern match in a <code>do</code> block fails.
Here’s an example:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="ot">someFunc ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>someFunc xs <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>  [a,b] <span class="ot">&lt;-</span> <span class="fu">pure</span> xs</span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> (a <span class="op">+</span> b)</span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a>  someFunc [<span class="dv">1</span>,<span class="dv">3</span>]</span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a>  someFunc [<span class="dv">2</span>]</span></code></pre></div>
<p>Running it with GHC 9.12:</p>
<pre><code>$ runghc-9.12 fail.hs
4
fail.hs: Uncaught exception ghc-internal:GHC.Internal.Exception.ErrorCall:

user error (Pattern match failure in &#39;do&#39; block at fail.hs:3:3-7)</code></pre>
<p>Running the same code with GHC 9.14:</p>
<pre><code>$ runghc-9.14 fail.hs
4
fail.hs: Uncaught exception ghc-internal:GHC.Internal.Exception.ErrorCall:

user error (Pattern match failure in &#39;do&#39; block at fail.hs:3:3-7)

HasCallStack backtrace:
  throwIO, called at libraries/ghc-internal/src/GHC/Internal/Control/Monad/Fail.hs:66:12 in ghc-internal:GHC.Internal.Control.Monad.Fail
  a type signature in an instance, called at libraries/ghc-internal/src/GHC/Internal/Control/Monad/Fail.hs:65:13 in ghc-internal:GHC.Internal.Control.Monad.Fail
  a do statement, called at fail.hs:3:3 in main:Main</code></pre>
<p>In GHC 9.14, the error message now includes a stack trace.
In this particular example, the benefit may be limited because the failing pattern match location (<code>fail.hs:3:3-7</code>) is already reported.</p>
<p>By adding <code>HasCallStack</code> to a function, you can include information about where the function was called. For example, adding it to <code>someFunc</code> shows the caller location:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.Stack</span> (<span class="dt">HasCallStack</span>)</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a><span class="ot">someFunc ::</span> <span class="dt">HasCallStack</span> <span class="ot">=&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>someFunc xs <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>  [a,b] <span class="ot">&lt;-</span> <span class="fu">pure</span> xs</span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> (a <span class="op">+</span> b)</span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true" tabindex="-1"></a>  someFunc [<span class="dv">1</span>,<span class="dv">3</span>]</span>
<span id="cb40-11"><a href="#cb40-11" aria-hidden="true" tabindex="-1"></a>  someFunc [<span class="dv">2</span>]</span></code></pre></div>
<p>Running with GHC 9.12:</p>
<pre><code>$ runghc-9.12 fail2.hs
4
fail2.hs: Uncaught exception ghc-internal:GHC.Internal.Exception.ErrorCall:

user error (Pattern match failure in &#39;do&#39; block at fail2.hs:5:3-7)</code></pre>
<p>Running with GHC 9.14:</p>
<pre><code>$ runghc-9.14 fail2.hs
4
fail2.hs: Uncaught exception ghc-internal:GHC.Internal.Exception.ErrorCall:

user error (Pattern match failure in &#39;do&#39; block at fail2.hs:5:3-7)

HasCallStack backtrace:
  throwIO, called at libraries/ghc-internal/src/GHC/Internal/Control/Monad/Fail.hs:66:12 in ghc-internal:GHC.Internal.Control.Monad.Fail
  a type signature in an instance, called at libraries/ghc-internal/src/GHC/Internal/Control/Monad/Fail.hs:65:13 in ghc-internal:GHC.Internal.Control.Monad.Fail
  a do statement, called at fail2.hs:5:3 in main:Main
  someFunc, called at fail2.hs:11:3 in main:Main</code></pre>
<p>In GHC 9.14, the stack trace now includes the location in the <code>main</code> function (<code>fail2.hs:11:3</code>).</p>
<h3 id="introduction-of-data.enum.enumerate">Introduction of <code>Data.Enum.enumerate</code></h3>
<ul>
<li><a href="https://github.com/haskell/core-libraries-committee/issues/306">enumerate Function · Issue #306 · haskell/core-libraries-committee</a></li>
</ul>
<p>A new function <code>enumerate</code> has been added that returns a list containing all elements of an enumeration type. Previously, many people would use the pattern <code>[minBound..maxBound]</code>.</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Enum</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Color</span> <span class="ot">=</span> <span class="dt">Red</span> <span class="op">|</span> <span class="dt">Green</span> <span class="op">|</span> <span class="dt">Blue</span> <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Enum</span>, <span class="dt">Bounded</span>)</span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> ([<span class="fu">minBound</span><span class="op">..</span><span class="fu">maxBound</span>]<span class="ot"> ::</span> [<span class="dt">Color</span>])</span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> (enumerate <span class="op">@</span><span class="dt">Color</span>)</span></code></pre></div>
<pre><code>$ runghc-9.14 enum.hs 
[Red,Green,Blue]
[Red,Green,Blue]</code></pre>
<h1 id="extra-my-contributions">Extra: My Contributions</h1>
<p>I (Mizuki) am jotting down a record of my contributions—bug reports, fixes, etc.—that made it into GHC 9.14.</p>
<ul>
<li>Enable compilation of integer SIMD primitives on the x86 NCG backend.
<ul>
<li><a href="https://gitlab.haskell.org/ghc/ghc/-/issues/25487">#25487: x86 NCG SIMD: Implement pack/insert/broadcast/unpack for integer vectors · Issues · Glasgow Haskell Compiler / GHC · GitLab</a></li>
<li><a href="https://gitlab.haskell.org/ghc/ghc/-/issues/25643">#25643: x86 NCG SIMD: Implement arithmetic operations for integer vectors · Issues · Glasgow Haskell Compiler / GHC · GitLab</a></li>
</ul></li>
<li>Enable compilation of floating-point shuffle on x86 NCG using SSE2 instructions (instead of AVX).
<ul>
<li><a href="https://gitlab.haskell.org/ghc/ghc/-/issues/26096">#26096: Better lowering for shuffleFloatX4# and shuffleDoubleX2# · Issues · Glasgow Haskell Compiler / GHC · GitLab</a></li>
</ul></li>
<li>Fix for arithmetic right shift on AArch64 NCG.
<ul>
<li><a href="https://gitlab.haskell.org/ghc/ghc/-/issues/26061">#26061: Sub-word arithmetic right shift with AArch64 NCG · Issues · Glasgow Haskell Compiler / GHC · GitLab</a></li>
<li>Scheduled to be backported to GHC 9.10.3 and also to the 9.12 series.</li>
</ul></li>
<li>Fix for <code>bswap64</code> on i386 NCG.
<ul>
<li><a href="https://gitlab.haskell.org/ghc/ghc/-/merge_requests/14363">!14363: x86 NCG: Fix code generation of bswap64 on i386 · Merge requests · Glasgow Haskell Compiler / GHC · GitLab</a></li>
<li>Scheduled to be backported to GHC 9.10.3 and also to the 9.12 series.</li>
</ul></li>
<li>Fix for LLVM version detection issues.
<ul>
<li><a href="https://gitlab.haskell.org/ghc/ghc/-/merge_requests/13763">!13763: Fix LLVM version detection (#25606) · Merge requests · Glasgow Haskell Compiler / GHC · GitLab</a></li>
<li>Backported to GHC 9.10.2 and scheduled for backport to the 9.12 series.</li>
</ul></li>
</ul>
<p>I do these contributions as a hobby.
I’m grateful that a few people have supported me via GitHub Sponsors:</p>
<ul>
<li><a href="https://github.com/sponsors/minoki">Sponsor <span class="citation" data-cites="minoki">@minoki</span> on GitHub Sponsors</a>
<ul>
<li>At the time of writing, I’m supported by <span class="citation" data-cites="toyboot4e">@toyboot4e</span> and <span class="citation" data-cites="kevin-kmetz">@kevin-kmetz</span>.</li>
</ul></li>
</ul>
<p>Thank you for reading, and enjoy your Haskell journey!</p>]]></description>
    <pubDate>Sun, 31 Aug 2025 00:00:00 UT</pubDate>
    <guid>https://minoki.github.io/posts/2025-08-31-whats-new-in-ghc-9-14.html</guid>
    <dc:creator>Arata Mizuki</dc:creator>
</item>
<item>
    <title>Some thoughts on GHC's SIMD primitives</title>
    <link>https://minoki.github.io/posts/2025-01-13-ghc-simd.html</link>
    <description><![CDATA[<p>The use of parallelization is essential to exploit the performance of modern computers.
In particular, we want to take advantage of SIMD, multi-core, and GPUs.
This article will focus on <em>SIMD</em> — single instruction, multiple data.</p>
<p>GHC has provided primitives for SIMD for years, but they have not been effectively utilized.</p>
<p>In this article, I’d like to discuss what can be done to promote the utilization of GHC’s SIMD primitives.</p>
<p><em>Disclaimer</em>: I’m not a high-performance computing expert —
just an enthusiast who enjoys experimenting with hardware capabilities for fun.</p>
<h2 id="current-status">Current Status</h2>
<h3 id="paper">Paper</h3>
<p>I must mention the following paper, which was written by the people who implemented SIMD primitives into GHC.</p>
<blockquote>
<p>Geoffrey Mainland, Roman Leshchinskiy and Simon Peyton Jones, Exploiting Vector Instructions with Generalized Stream Fusion, ICFP 2013</p>
</blockquote>
<p>In addition to GHC’s SIMD primitives, they seem to have considered integration with the <code>vector</code> package and Data Parallel Haskell (DPH).
However, integration with the <code>vector</code> package doesn’t seem to have happended, and DPH did not survive.</p>
<h3 id="design">Design</h3>
<p>When exposing SIMD features to programming languages, there is the question of how to abstract (or not to abstract) the architecture-dependent vector register width.</p>
<p>GHC provides 128-bit, 256-bit, and 512-bit wide types, respectively.
They correspond directly to the corresponding CPU registers.
In other words, on x86 systems, 512-bit wide vector types correspond to ZMM (AVX-512) registers and do not use two YMM registers or four XMM registers.</p>
<p>In contrast, LLVM’s abstraction allows vectors of arbitrary length to be written.
Vectors exceeding the machine’s SIMD width are compiled into multiple instructions or registers.</p>
<p>Under GHC’s current design, it is up to libraries to abstract away the architecture-dependent SIMD width.</p>
<h3 id="library">Library</h3>
<p>Since GHC’s SIMD primitive types are unboxed, one would want boxed wrappers for daily use.
With a Hackage search, I found two packages providing boxed wrappers:</p>
<ul>
<li><a href="https://hackage.haskell.org/package/simd">simd: simple interface to GHC’s SIMD instructions</a></li>
<li><a href="https://hackage.haskell.org/package/primitive-simd">primitive-simd: SIMD data types and functions</a></li>
</ul>
<p>The <code>simd</code> package is based on type families:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Data.SIMD.SIMD4</span> <span class="kw">where</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">SIMD4</span> a <span class="kw">where</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">data</span> <span class="dt">X4</span> a</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="ot">  plusX4 ::</span> <span class="dt">X4</span> a <span class="ot">-&gt;</span> <span class="dt">X4</span> a <span class="ot">-&gt;</span> <span class="dt">X4</span> a</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="ot">  indexArrayAsX4 ::</span> <span class="dt">ByteArray</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">X4</span> a</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="ot">  broadcastX4 ::</span> a <span class="ot">-&gt;</span> <span class="dt">X4</span> a</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- ...</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">SIMD4</span> a <span class="ot">=&gt;</span> <span class="dt">SIMD4Float</span> a <span class="kw">where</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="ot">  divideX4 ::</span> <span class="dt">X4</span> a <span class="ot">-&gt;</span> <span class="dt">X4</span> a <span class="ot">-&gt;</span> <span class="dt">X4</span> a</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">Show</span> a, <span class="dt">SIMD4</span> a) <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">X4</span> a)</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">Num</span> a, <span class="dt">SIMD4</span> a) <span class="ot">=&gt;</span> <span class="dt">Num</span> (<span class="dt">X4</span> a)</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">Fractional</span> a, <span class="dt">SIMD4Float</span> a) <span class="ot">=&gt;</span> <span class="dt">Fractional</span> (<span class="dt">X4</span> a)</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">SIMD4</span> <span class="dt">Float</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">SIMD4</span> <span class="dt">Double</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="co">-- ...</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a><span class="ot">vectorizeUnboxedX4 ::</span> (<span class="dt">SIMD4</span> a, <span class="dt">VU.Unbox</span> a) <span class="ot">=&gt;</span> <span class="dt">VU.Vector</span> a <span class="ot">-&gt;</span> <span class="dt">VU.Vector</span> (<span class="dt">X4</span> a)</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a><span class="ot">unVectorizeUnboxedX4 ::</span> (<span class="dt">SIMD4</span> a, <span class="dt">VU.Unbox</span> a) <span class="ot">=&gt;</span> <span class="dt">VU.Vector</span> (<span class="dt">X4</span> a) <span class="ot">-&gt;</span> <span class="dt">VU.Vector</span> a</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a><span class="ot">vectorizeStorableX4 ::</span> (<span class="dt">SIMD4</span> a, <span class="dt">Storable</span> a, <span class="dt">Storable</span> (<span class="dt">X4</span> a)) <span class="ot">=&gt;</span> <span class="dt">VS.Vector</span> a <span class="ot">-&gt;</span> <span class="dt">VS.Vector</span> (<span class="dt">X4</span> a)</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a><span class="ot">unVectorizeStorableX4 ::</span> (<span class="dt">SIMD4</span> a, <span class="dt">Storable</span> a, <span class="dt">Storable</span> (<span class="dt">X4</span> a)) <span class="ot">=&gt;</span> <span class="dt">VS.Vector</span> (<span class="dt">X4</span> a) <span class="ot">-&gt;</span> <span class="dt">VS.Vector</span> a</span></code></pre></div>
<p>This package organizes SIMD types by the number of elements, such as <code>X4</code>, <code>X8</code>, and <code>X16</code>.
One thing to note is that <code>X4 Double</code> is a wrapper for <code>DoubleX4#</code> and therefore requires AVX.</p>
<p>If you want to map over <code>Vector Float</code>, the vector’s length must be a multiple of 4.</p>
<p>Let’s see the other package, <code>primitive-simd</code>.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Data.Primitive.SIMD</span> <span class="kw">where</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> (<span class="dt">Num</span> v, <span class="dt">Real</span> (<span class="dt">Elem</span> v)) <span class="ot">=&gt;</span> <span class="dt">SIMDVector</span> v <span class="kw">where</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">Elem</span> v</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">ElemTuple</span> v</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="ot">  broadcastVector ::</span> <span class="dt">Elem</span> v <span class="ot">-&gt;</span> v</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="ot">  mapVector ::</span> (<span class="dt">Elem</span> v <span class="ot">-&gt;</span> <span class="dt">Elem</span> v) <span class="ot">-&gt;</span> v <span class="ot">-&gt;</span> v</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- ...</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">FloatX4</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">FloatX8</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">FloatX16</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">DoubleX2</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">DoubleX4</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">DoubleX8</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a><span class="co">-- ...</span></span></code></pre></div>
<p>It provides individual data types, not type families, for the vector types (it uses type families for obtaining the element type from vector types).</p>
<p>One interesting point is, <code>DoubleX4</code> does not always map to <code>DoubleX4#</code> and can be configured to use two <code>DoubleX2#</code>.
It allows to use <code>DoubleX4</code> on SSE-only machines, or NEON-only Arm machines.</p>
<p>I like the idea of using type families like <code>X4</code>/<code>X8</code>/<code>X16</code>, and I like the idea of using two <code>DoubleX2#</code> for <code>X4 Double</code>/<code>DoubleX4</code>.
I’ll come back to this point later.</p>
<h2 id="improvements-to-ghc">Improvements to GHC</h2>
<p>This section explores ways to make GHC’s SIMD primitives more accessible and practical for users.</p>
<h3 id="expanding-backend-support">Expanding Backend Support</h3>
<p>Historically (in GHC &lt; 9.8), using SIMD primitives required:</p>
<ol type="1">
<li>The LLVM backend</li>
<li>An x86(-64) machine</li>
</ol>
<p>This situation was not great because</p>
<ul>
<li>you need to install LLVM toolchain in addition to GHC, and</li>
<li>some of the modern computers are not x86-based (for instance, I’m writing this article with an Apple Silicon Mac).</li>
</ul>
<p>With SIMD primitives limited to few backends, it’s no surprise that a package authors have been hesitant to adopt them.
To encourange broader use, GHC should support SIMD primitives across more backends.</p>
<p>Recently, some progress is being made in this area.
The following sections will detail these advancements.</p>
<h4 id="x86-64-ncg">x86(-64) NCG</h4>
<p>Currently, the most popular architecture for PCs is x86-64.
Therefore, it would be beneficial to make the x86(-64) NCG support SIMD primitives.</p>
<p>Now, GHC 9.12 added some support for SIMD with x86-64 NCG.
The work originally started as a GSoC project in 2018 and was once merged in 2019, but later reverted because of incomplete handling of register spilling.</p>
<ul>
<li><a href="https://gist.github.com/Abhiroop/9a2600f24f8139b7fc0742a2b4585bb3">GSoC final evaluation</a></li>
<li><a href="https://gitlab.haskell.org/ghc/ghc/-/issues/7741">#7741: Add SIMD support to x86/x86_64 NCG · Issues · Glasgow Haskell Compiler / GHC · GitLab</a></li>
<li><a href="https://gitlab.haskell.org/ghc/ghc/-/merge_requests/1306">!1306: AVX/SSE4 SIMD support for the native code generator · Merge requests · Glasgow Haskell Compiler / GHC · GitLab</a></li>
<li><a href="https://gitlab.haskell.org/ghc/ghc/-/merge_requests/1379">!1379: Back out SIMD NCG support · Merge requests · Glasgow Haskell Compiler / GHC · GitLab</a></li>
</ul>
<p>Last year (2024), <a href="https://gitlab.haskell.org/sheaf"><span class="citation" data-cites="sheaf">@sheaf</span></a> and <a href="https://gitlab.haskell.org/jaro"><span class="citation" data-cites="jaro">@jaro</span></a> continued the work and managed to get basic support of SIMD into x86(-64) NCG.</p>
<ul>
<li><a href="https://gitlab.haskell.org/ghc/ghc/-/merge_requests/12860">!12860: Add SIMD support to the X86 NCG · Merge requests · Glasgow Haskell Compiler / GHC · GitLab</a></li>
<li><a href="https://gitlab.haskell.org/ghc/ghc/-/merge_requests/12857">!12857: Add Int64X2 SIMD operations · Merge requests · Glasgow Haskell Compiler / GHC · GitLab</a></li>
</ul>
<p>The initial implementation was limited to <code>FloatX4#</code>, <code>DoubleX2#</code> (and packing/unpacking of <code>Int64X2#</code>) and some operations required SSE4.1 instructions (by default, GHC refuses to use SSE instructions beyond SSE2).
Since then, I have worked to make NCG emit SSE1 instructions for basic <code>FloatX4#</code> operations:</p>
<ul>
<li><a href="https://gitlab.haskell.org/ghc/ghc/-/issues/25441">#25441: x86 NCG SIMD: Primitives like insertFloatX4# should be available without -msse4 · Issues · Glasgow Haskell Compiler / GHC · GitLab</a></li>
<li><a href="https://gitlab.haskell.org/ghc/ghc/-/merge_requests/13542">!13542: x86 NCG SIMD: Lower packFloatX4#, insertFloatX4# and broadcastFloatX4# to SSE1 instructions · Merge requests · Glasgow Haskell Compiler / GHC · GitLab</a> (backported to GHC 9.12)</li>
</ul>
<p>and I implemented packing/unpacking of other integer vector types:</p>
<ul>
<li><a href="https://gitlab.haskell.org/ghc/ghc/-/issues/25487">#25487: x86 NCG SIMD: Implement pack/insert/broadcast/unpack for integer vectors · Issues · Glasgow Haskell Compiler / GHC · GitLab</a></li>
<li><a href="https://gitlab.haskell.org/ghc/ghc/-/merge_requests/13602">!13602: x86 NCG SIMD: Support pack/insert/broadcast/unpack of 128-bit integer vectors · Merge requests · Glasgow Haskell Compiler / GHC · GitLab</a> (will be in GHC 9.14)</li>
</ul>
<p>and now I’m working on to support arithmetic operations of integer vector types:</p>
<ul>
<li><a href="https://gitlab.haskell.org/ghc/ghc/-/issues/25643">#25643: x86 NCG SIMD: Implement arithmetic operations for integer vectors · Issues · Glasgow Haskell Compiler / GHC · GitLab</a></li>
<li><a href="https://gitlab.haskell.org/ghc/ghc/-/merge_requests/13810">!13810: Draft: x86 NCG SIMD: Implement 128-bit integer vector arithmetics · Merge requests · Glasgow Haskell Compiler / GHC · GitLab</a></li>
</ul>
<p>Although there are many tasks to be done (256-bit and 512-bit support via AVX/AVX-512/AVX10, better code generation, etc<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>), the progress is promising.</p>
<h4 id="aarch64-llvmncg">AArch64 LLVM/NCG</h4>
<p>The next most popular architecture for PCs is probably AArch64 (Arm64).
Therefore, it should be supported as well.</p>
<p>AArch64 offers 128-bit wide ASIMD (NEON) instructions and optional SVE.
NEON aligns well with GHC’s design, so it is the first target.</p>
<p>Supporting NEON via LLVM should be easy, and actually I did it in 2023:</p>
<ul>
<li><a href="https://gitlab.haskell.org/ghc/ghc/-/issues/23410">#23410: Support 128-bit SIMD on AArch64 via LLVM backend · Issues · Glasgow Haskell Compiler / GHC · GitLab</a></li>
<li><a href="https://gitlab.haskell.org/ghc/ghc/-/merge_requests/10456">!10456: Support 128-bit SIMD on AArch64 via LLVM backend · Merge requests · Glasgow Haskell Compiler / GHC · GitLab</a></li>
</ul>
<p>So GHC 9.8 has support for SIMD on AArch64 via LLVM backend.
If you are using ghcup on macOS, you can enable LLVM backend (<code>-fllvm</code>) via the following command:</p>
<pre><code>$ brew install llvm@15
$ OPT=$(brew --prefix llvm@15)/bin/opt \
    LLC=$(brew --prefix llvm@15)/bin/llc \
    ghcup install ghc --force 9.8.4</code></pre>
<p>(See also <a href="https://minoki.github.io/posts/2025-01-06-ghc-llvm-backend.html">How to use GHC’s LLVM backend</a>)</p>
<p>Support via the NCG backend is also desirable, but it would be a non-trivial task.</p>
<h4 id="webassembly">WebAssembly</h4>
<p>WebAssembly has 128-bit wide SIMD, so it would be good to have support for them.</p>
<p>There is an issue: <a href="https://gitlab.haskell.org/ghc/ghc/-/issues/22618">#22618: Add SIMD128 support to the wasm backend · Issues · Glasgow Haskell Compiler / GHC · GitLab</a></p>
<h4 id="other-targets">Other Targets</h4>
<p>Some of the other targets have support for SIMD, but with some notes.</p>
<p>PowerPC has 128-bit AltiVec, but does not support double precision floating-points.
Should GHC emulate <code>DoubleX2#</code> via scalar operations, or choose not to support it?</p>
<p>32-bit Arm has NEON as an extension, but the floating-point vector operations do not support subnormals (they always use flush-to-zero mode).
Is this acceptable?
Should GHC use floating-point vector instructions only if <code>-ffast-math</code> is set?</p>
<p>RISC-V has vector extension, but I don’t know how close its design is to GHC’s design.
There is some effort:</p>
<ul>
<li><a href="https://gitlab.haskell.org/ghc/ghc/-/issues/25331">#25331: RISC-V vector extension support (SIMD) · Issues · Glasgow Haskell Compiler / GHC · GitLab</a></li>
<li><a href="https://gitlab.haskell.org/ghc/ghc/-/merge_requests/13467">!13467: Draft: RISC-V vectors · Merge requests · Glasgow Haskell Compiler / GHC · GitLab</a></li>
</ul>
<p>Other backends (like via-C or JS) has no SIMD support.</p>
<h3 id="more-primitives">More Primitives</h3>
<p>The number of operations implemented in current GHC is quite limited.
Traditionally (GHC ≤ 9.10), the available operations were the following:</p>
<ul>
<li>Basic operations
<ul>
<li><code>pack</code></li>
<li><code>insert</code></li>
<li><code>unpack</code></li>
<li><code>broadcast</code></li>
<li><code>index</code>/<code>read</code>/<code>write</code> for arrays and pointers</li>
</ul></li>
<li><code>plus</code></li>
<li><code>minus</code></li>
<li><code>times</code></li>
<li><code>divide</code> (for floating-points)</li>
<li><code>quot</code>/<code>rem</code> (for integers)
<ul>
<li>Interestingly, there is no SIMD instructions for integer division on x86.</li>
</ul></li>
<li><code>negate</code> (for signed integers and floating-points)</li>
</ul>
<p>In GHC 9.12, additional primitives such as <code>min</code>, <code>max</code>, FMA, and <code>shuffle</code> were introduced.</p>
<p>Still, some operations that are frequently used are missing:</p>
<ul>
<li><code>sqrt</code></li>
<li><code>abs</code></li>
<li>Bitwise operations</li>
</ul>
<p>In fact, the LLVM backend can generate these instructions without dedicated vector primitives.
For example, LLVM’s optimizer would fuse the following code into a vector instruction:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>sqrtFloatX4<span class="op">#</span><span class="ot"> ::</span> <span class="dt">FloatX4</span><span class="op">#</span> <span class="ot">-&gt;</span> <span class="dt">FloatX4</span><span class="op">#</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>sqrtFloatX4<span class="op">#</span> v <span class="ot">=</span> <span class="kw">case</span> unpackFloatX4<span class="op">#</span> v <span class="kw">of</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  (<span class="op">#</span> x0, x1, x2, x3 <span class="op">#</span>) <span class="ot">-&gt;</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    packFloatX4<span class="op">#</span> (<span class="op">#</span> sqrtFloat<span class="op">#</span> x0</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>                  , sqrtFloat<span class="op">#</span> x1</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>                  , sqrtFloat<span class="op">#</span> x2</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>                  , sqrtFloat<span class="op">#</span> x3 <span class="op">#</span>)</span></code></pre></div>
<p>Nevertheless, adding dedicated vector primitives for these operations would be desirable, because implementing such optimizations in the NCG would not be pleasant.</p>
<p>In addition to these, primitives related to conditionals (or masks) are currently missing.
Comparison operations, logical operations, conditional selection, and so on.
It is worth considering how to represent masks.
Should we introduce a generic type like <code>BoolX4#</code> that is independent of the vector’s element type (like LLVM’s abstraction), or should we define type-specific masks such as <code>FloatX4Mask#</code> for each vector type?</p>
<h3 id="ffi">FFI</h3>
<p>With the <code>UnliftedFFITypes</code> extension enabled, vector types can be used in FFI.</p>
<p>However, on Windows, the default C calling convention requires all 128-bit vectors to be passed by reference.
To address this, it may be beneficial to support the <code>vectorcall</code> calling convention, which allows vector arguments to be passed directly in registers.</p>
<h2 id="designing-a-simd-library">Designing a SIMD Library</h2>
<p>SIMD primitives are low-level features and not for end-users.
As mentioned earlier, libraries should provide user-friendly wrappers.
But what should such a library look like?</p>
<h3 id="boxed-wrappers">Boxed Wrappers</h3>
<p>The use of type families to define wrappers based on the number of elements, as seen in the <code>simd</code> package, is an elegant approach.
This design has the advantage of being isomorphic to fixed-length vector types, for example:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Pseudocode</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">X4</span> a <span class="ot">=</span> <span class="dt">X4</span> <span class="op">!</span>a <span class="op">!</span>a <span class="op">!</span>a <span class="op">!</span>a</span></code></pre></div>
<p>Another appealing idea is the approach taken by the <code>primitive-simd</code> package, which uses two <code>DoubleX2#</code> values to represent a vector of four <code>Double</code>s.
This allows for flexibility in supporting platforms with varying SIMD capabilities.</p>
<p>Combining these ideas, my proposed wrapper types would look like this:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">X4</span> a</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="kw">instance</span> <span class="dt">X4</span> <span class="dt">Float</span> <span class="ot">=</span> <span class="dt">FloatX4</span> <span class="dt">FloatX4</span><span class="op">#</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#if MAX_VEC_LEN == 128</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="kw">instance</span> <span class="dt">X4</span> <span class="dt">Double</span> <span class="ot">=</span> <span class="dt">DoubleX2X2</span> <span class="dt">DoubleX2</span><span class="op">#</span> <span class="dt">DoubleX2</span><span class="op">#</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#elif MAX_VEC_LEN &gt;= 256</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="kw">instance</span> <span class="dt">X4</span> <span class="dt">Double</span> <span class="ot">=</span> <span class="dt">DoubleX4</span> <span class="dt">DoubleX4</span><span class="op">#</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span></code></pre></div>
<h3 id="type-classes">Type Classes</h3>
<p>Let’s consider the type classes.
I want to have instances like these:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="op">???</span> a) <span class="ot">=&gt;</span> <span class="dt">Num</span> (<span class="dt">X4</span> a)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="op">???</span> a) <span class="ot">=&gt;</span> <span class="dt">Fractional</span> (<span class="dt">X4</span> a)</span></code></pre></div>
<p>What should the superclass constraints (<code>??? a</code>) be?
One approach is to define specialized classes for <code>X4</code>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">BroadcastX4</span> a <span class="kw">where</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  broadcastX4 ::</span> a <span class="ot">-&gt;</span> <span class="dt">X4</span> a</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">BroadcastX4</span> <span class="dt">Float</span> <span class="kw">where</span> <span class="op">...</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">BroadcastX4</span> <span class="dt">Double</span> <span class="kw">where</span> <span class="op">...</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">BroadcastX4</span> a <span class="ot">=&gt;</span> <span class="dt">NumX4</span> a <span class="kw">where</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="ot">  plusX4 ::</span> <span class="dt">X4</span> a <span class="ot">-&gt;</span> <span class="dt">X4</span> a <span class="ot">-&gt;</span> <span class="dt">X4</span> a</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- ...</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">NumX4</span> <span class="dt">Float</span> <span class="kw">where</span> <span class="op">..</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">NumX4</span> <span class="dt">Double</span> <span class="kw">where</span> <span class="op">..</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">Num</span> a, <span class="dt">NumX4</span> a) <span class="ot">=&gt;</span> <span class="dt">Num</span> (<span class="dt">X4</span> a) <span class="kw">where</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>  (<span class="op">+</span>) <span class="ot">=</span> plusX4</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- ...</span></span></code></pre></div>
<p>A more general approach would allow for other vector lengths, such as <code>X8</code> or <code>X16</code>:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Broadcast</span> f a <span class="kw">where</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  broadcast ::</span> a <span class="ot">-&gt;</span> f a</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Broadcast</span> <span class="dt">X4</span> <span class="dt">Float</span> <span class="kw">where</span> <span class="op">...</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Broadcast</span> <span class="dt">X4</span> <span class="dt">Double</span> <span class="kw">where</span> <span class="op">...</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- instances for X8, X16 could be added</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Broadcast</span> f a <span class="ot">=&gt;</span> <span class="dt">NumF</span> f a <span class="kw">where</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a><span class="ot">  plusF ::</span> f a <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f a</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a><span class="ot">  minusF ::</span> f a <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f a</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a><span class="ot">  timesF ::</span> f a <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f a</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a><span class="ot">  absF ::</span> f a <span class="ot">-&gt;</span> f a</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a><span class="ot">  signumF ::</span> f a <span class="ot">-&gt;</span> f a</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a><span class="ot">  negateF ::</span> f a <span class="ot">-&gt;</span> f a</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">NumF</span> <span class="dt">X4</span> <span class="dt">Float</span> <span class="kw">where</span> <span class="op">...</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">NumF</span> <span class="dt">X4</span> <span class="dt">Double</span> <span class="kw">where</span> <span class="op">...</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a><span class="co">-- instances for X8, X16 could be added</span></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">NumF</span> <span class="dt">X4</span> a, <span class="dt">Num</span> a) <span class="ot">=&gt;</span> <span class="dt">Num</span> (<span class="dt">X4</span> a) <span class="kw">where</span></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>  (<span class="op">+</span>) <span class="ot">=</span> plusF</span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- ...</span></span></code></pre></div>
<h3 id="mapping-a-long-vector">Mapping a Long Vector</h3>
<p>To process a (long) vector using SIMD data types, let’s define <code>Storable</code>-like classes:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Storable</span> a <span class="ot">=&gt;</span> <span class="dt">StorableF</span> f a <span class="kw">where</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  peekElemOffF ::</span> <span class="dt">Ptr</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (f a) <span class="co">-- index in scalar elements</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  pokeElemOffF ::</span> <span class="dt">Ptr</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">IO</span> () <span class="co">-- index in scalar elements</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">StorableF</span> <span class="dt">X4</span> <span class="dt">Float</span> <span class="kw">where</span> <span class="op">...</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">StorableF</span> <span class="dt">X4</span> <span class="dt">Double</span> <span class="kw">where</span> <span class="op">...</span></span></code></pre></div>
<p>Using these, a <code>map</code> function that supports SIMD could be implemented like this:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ot">mapStorable ::</span> (<span class="dt">StorableF</span> <span class="dt">X4</span> a, <span class="dt">StorableF</span> <span class="dt">X4</span> b)</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>            <span class="ot">=&gt;</span> (<span class="dt">X4</span> a <span class="ot">-&gt;</span> <span class="dt">X4</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b)</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>            <span class="ot">-&gt;</span> <span class="dt">VS.Vector</span> a <span class="ot">-&gt;</span> <span class="dt">VS.Vector</span> b</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>mapStorable fv f <span class="op">!</span>v <span class="ot">=</span> unsafePerformIO <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="op">!</span>n <span class="ot">=</span> VS.length v</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">!</span>result <span class="ot">&lt;-</span> VSM.unsafeNew n</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>  VS.unsafeWith v <span class="op">$</span> \ <span class="op">!</span>inputPtr <span class="ot">-&gt;</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    VSM.unsafeWith result <span class="op">$</span> \ <span class="op">!</span>resultPtr <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> loopVector <span class="op">!</span>i <span class="op">|</span> i <span class="op">+</span> <span class="dv">4</span> <span class="op">&gt;</span> n <span class="ot">=</span> loopScalar i</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>                        <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>                          <span class="op">!</span>a <span class="ot">&lt;-</span> peekElemOffF inputPtr i</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>                          pokeElemOffF resultPtr i (fv a)</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>                          loopVector (i <span class="op">+</span> <span class="dv">4</span>)</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>          loopScalar <span class="op">!</span>i <span class="op">|</span> i <span class="op">&gt;=</span> n <span class="ot">=</span> <span class="fu">pure</span> ()</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>                        <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>                          <span class="op">!</span>a <span class="ot">&lt;-</span> peekElemOff inputPtr i</span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>                          pokeElemOff resultPtr i (f a)</span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>                          loopScalar (i <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>      loopVector <span class="dv">0</span></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>  VS.unsafeFreeze result</span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# INLINE mapStorable #-}</span></span></code></pre></div>
<p>For simplicity, fusion-like optimizations are not implemented.</p>
<p>A use of this function would look like:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>mapStorable (\v <span class="ot">-&gt;</span> (v <span class="op">+</span> <span class="dv">1</span>)<span class="op">^</span>(<span class="dv">10</span><span class="ot"> ::</span> <span class="dt">Int</span>))</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>            (\x <span class="ot">-&gt;</span> (x <span class="op">+</span> <span class="dv">1</span>)<span class="op">^</span>(<span class="dv">10</span><span class="ot"> ::</span> <span class="dt">Int</span>))</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>            (VS.fromList [<span class="dv">0</span><span class="op">..</span><span class="dv">10</span>]<span class="ot"> ::</span> <span class="dt">VS.Vector</span> <span class="dt">Float</span>)</span></code></pre></div>
<h3 id="unifying-the-simd-and-scalar-parts">Unifying the SIMD and Scalar Parts</h3>
<p>The <code>mapStorable</code> function that we just defined requires separate functions for SIMD (<code>X4 a -&gt; X4 b</code>) and scalar (<code>a -&gt; b</code>) operations, leading to code duplication.
Can we avoid this?</p>
<p>If the operation is <code>f x = (x + 1)^10</code>, the function type could be generalized to <code>Num a =&gt; a -&gt; a</code>, and we could have:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ot">mapStorableNum ::</span> (<span class="dt">StorableF</span> <span class="dt">X4</span> a, <span class="dt">Num</span> a, <span class="dt">NumF</span> <span class="dt">X4</span> a)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>               <span class="ot">=&gt;</span> (<span class="kw">forall</span> v<span class="op">.</span> <span class="dt">Num</span> v <span class="ot">=&gt;</span> v <span class="ot">-&gt;</span> v)</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>               <span class="ot">-&gt;</span> <span class="dt">VS.Vector</span> a <span class="ot">-&gt;</span> <span class="dt">VS.Vector</span> a</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>mapStorableNum f <span class="ot">=</span> mapStorable f f</span></code></pre></div>
<p>However, this approach requires separate <code>map</code> functions for each constraints (<code>Num</code>, <code>Fractional</code>, <code>Bits</code>, etc.), which is undesirable.</p>
<p>Let’s consider another approach.
The scalar function is isomorphic to <code>Identity a -&gt; Identity b</code>, so both the SIMD part and scalar part could be written as <code>f a -&gt; f b</code>.
I mean, if we have a type class <code>SIMD</code> with <code>X4</code> and <code>Identity</code> as instances, then we could write:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ot">mapStorable&#39; ::</span> (<span class="dt">StorableF</span> <span class="dt">X4</span> a, <span class="dt">Storable</span> <span class="dt">X4</span> b)</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>             <span class="ot">=&gt;</span> (<span class="kw">forall</span> f<span class="op">.</span> <span class="dt">SIMD</span> f <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> f b)</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>             <span class="ot">-&gt;</span> <span class="dt">VS.Vector</span> a <span class="ot">-&gt;</span> <span class="dt">VS.Vector</span> b</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>mapStorable&#39; f <span class="ot">=</span> mapStorable f (runIdentity <span class="op">.</span> f <span class="op">.</span> <span class="dt">Identity</span>)</span></code></pre></div>
<p>What should the <code>SIMD f</code> constraint be?
<code>f</code> should have instances like <code>Num (f Float)</code>, <code>Num (f Double)</code>.
Ideally, we would like to have <code>Num (f a)</code> for any <code>Num a</code>.
That is:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> (<span class="kw">forall</span> a<span class="op">.</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Num</span> (f a)) <span class="ot">=&gt;</span> <span class="dt">SIMD</span> f</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">SIMD</span> <span class="dt">Identity</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">SIMD</span> <span class="dt">X4</span></span></code></pre></div>
<p>…except that it’s impossible.
We defined <code>X4 a</code> only for <code>a ~ Float</code> and <code>a ~ Double</code>.
We are not going to have <code>X4 Integer</code> or <code>X4 Rational</code>.
So, let’s add the additional constraint:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> (<span class="kw">forall</span> a<span class="op">.</span> (<span class="dt">Num</span> a, <span class="dt">NumF</span> <span class="dt">X4</span> a) <span class="ot">=&gt;</span> <span class="dt">Num</span> (f a)) <span class="ot">=&gt;</span> <span class="dt">SIMD</span> f</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">SIMD</span> <span class="dt">Identity</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">SIMD</span> <span class="dt">X4</span></span></code></pre></div>
<p>If we are going to have types for other element-counts like <code>X8</code> or <code>X16</code>, we can add them:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> ( <span class="kw">forall</span> a<span class="op">.</span> (<span class="dt">Num</span> a, <span class="dt">NumF</span> <span class="dt">X4</span> a, <span class="dt">NumF</span> <span class="dt">X8</span> a, <span class="dt">NumF</span> <span class="dt">X16</span> a) <span class="ot">=&gt;</span> <span class="dt">Num</span> (f a)</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>      ) <span class="ot">=&gt;</span> <span class="dt">SIMD</span> f</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">SIMD</span> <span class="dt">Identity</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">SIMD</span> <span class="dt">X4</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">SIMD</span> <span class="dt">X8</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">SIMD</span> <span class="dt">X16</span></span></code></pre></div>
<p>If we are going to support other type classes, we can add them:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">NumElement</span> a <span class="ot">=</span> (<span class="dt">Num</span> a, <span class="dt">NumF</span> <span class="dt">X4</span> a, <span class="dt">NumF</span> <span class="dt">X8</span> a, <span class="dt">NumF</span> <span class="dt">X16</span> a)</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">FractionalElement</span> a <span class="ot">=</span> (<span class="dt">Fractional</span> a, <span class="dt">FractionalF</span> <span class="dt">X4</span> a,</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>                            <span class="dt">FractionalF</span> <span class="dt">X8</span> a, <span class="dt">FractionalF</span> <span class="dt">X16</span> a)</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">FloatingElement</span> a <span class="ot">=</span> (<span class="dt">Floating</span> a, <span class="dt">FloatingF</span> <span class="dt">X4</span> a,</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>                          <span class="dt">FloatingF</span> <span class="dt">X8</span> a, <span class="dt">FloatingF</span> <span class="dt">X16</span> a)</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">MonoidElement</span> a <span class="ot">=</span> (<span class="dt">Monoid</span> a, <span class="dt">MonoidF</span> <span class="dt">X4</span> a, <span class="dt">MonoidF</span> <span class="dt">X8</span> a, <span class="dt">MonoidF</span> <span class="dt">X16</span> a)</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> ( <span class="kw">forall</span> a<span class="op">.</span> <span class="dt">NumElement</span> a <span class="ot">=&gt;</span> <span class="dt">Num</span> (f a)</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>      , <span class="kw">forall</span> a<span class="op">.</span> <span class="dt">FractionalElement</span> a <span class="ot">=&gt;</span> <span class="dt">Fractional</span> (f a)</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>      , <span class="kw">forall</span> a<span class="op">.</span> <span class="dt">FloatingElement</span> a <span class="ot">=&gt;</span> <span class="dt">Floating</span> (f a)</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>      , <span class="kw">forall</span> a<span class="op">.</span> <span class="dt">MonoidElement</span> a <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (f a)</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>      ) <span class="ot">=&gt;</span> <span class="dt">SIMD</span> f</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">SIMD</span> <span class="dt">Identity</span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">SIMD</span> <span class="dt">X4</span></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">SIMD</span> <span class="dt">X8</span></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">SIMD</span> <span class="dt">X16</span></span></code></pre></div>
<p>The user can write as</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>f x <span class="ot">=</span> (x <span class="op">+</span> <span class="dv">1</span>)<span class="op">^</span>(<span class="dv">10</span><span class="ot"> ::</span> <span class="dt">Int</span>)</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>mapStorable&#39; f (VS.fromList [<span class="dv">0</span><span class="op">..</span><span class="dv">10</span>])</span></code></pre></div>
<p>or</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="ot">g ::</span> (<span class="dt">SIMD</span> f, <span class="dt">NumElement</span> a) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> f a</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>g x <span class="ot">=</span> (x <span class="op">+</span> <span class="dv">1</span>)<span class="op">^</span>(<span class="dv">10</span><span class="ot"> ::</span> <span class="dt">Int</span>)</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>mapStorable&#39; g (VS.fromList [<span class="dv">0</span><span class="op">..</span><span class="dv">10</span>])</span></code></pre></div>
<h3 id="a-working-example">A Working Example</h3>
<p>I have a working example for SIMD at <a href="https://github.com/minoki/haskell-dsl-example/tree/main/simd">haskell-dsl-example/simd</a>.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="op">$</span> git clone https<span class="op">://</span>github<span class="op">.</span>com<span class="op">/</span>minoki<span class="op">/</span>haskell<span class="op">-</span>dsl<span class="op">-</span>example<span class="op">.</span>git</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="op">$</span> cd haskell<span class="op">-</span>dsl<span class="op">-</span>example<span class="op">/</span>simd</span></code></pre></div>
<p>I use an Apple Silicon Mac, so I need to use GHC 9.8+ with LLVM backend enabled.</p>
<pre><code>$ cabal configure -w ghc-9.8.4 --ghc-options=-fllvm</code></pre>
<p>A successful run of <code>cabal run</code> looks like:</p>
<pre><code>$ cabal run
[1.0,1024.0,59049.0,1048576.0,9765625.0,6.0466176e7,2.8247526e8,1.0737418e9,3.4867843e9,1.0e10,2.5937424e10]
[1.0,1024.0,59049.0,1048576.0,9765625.0,6.0466176e7,2.8247526e8,1.0737418e9,3.4867843e9,1.0e10,2.5937424e10]
[1.0,1024.0,59049.0,1048576.0,9765625.0,6.0466176e7,2.8247526e8,1.0737418e9,3.4867843e9,1.0e10,2.5937424e10]
[1.0,1024.0,59049.0,1048576.0,9765625.0,6.0466176e7,2.8247526e8,1.0737418e9,3.4867843e9,1.0e10,2.5937424e10]
[1.0,1024.0,59049.0,1048576.0,9765625.0,6.0466176e7,2.82475249e8,1.073741824e9,3.486784401e9,1.0e10,2.5937424601e10]
[1.0,1024.0,59049.0,1048576.0,9765625.0,6.0466176e7,2.82475249e8,1.073741824e9,3.486784401e9,1.0e10,2.5937424601e10]
[1.0,1024.0,59049.0,1048576.0,9765625.0,6.0466176e7,2.82475249e8,1.073741824e9,3.486784401e9,1.0e10,2.5937424601e10]
[1.0,1024.0,59049.0,1048576.0,9765625.0,6.0466176e7,2.82475249e8,1.073741824e9,3.486784401e9,1.0e10,2.5937424601e10]</code></pre>
<p>The benchmark is available at <a href="https://github.com/minoki/haskell-dsl-example/blob/main/simd/benchmark/Main.hs">simd/benchmark/Main.hs</a>.
I defined two functions to benchmark:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>f x <span class="ot">=</span> (x <span class="op">+</span> <span class="dv">1</span>)<span class="op">^</span>(<span class="dv">10</span><span class="ot"> ::</span> <span class="dt">Int</span>)</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# INLINE f #-}</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a><span class="ot">g ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>g x <span class="ot">=</span> <span class="kw">let</span> y <span class="ot">=</span> x <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>          y2 <span class="ot">=</span> y <span class="op">*</span> y</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>          y4 <span class="ot">=</span> y2 <span class="op">*</span> y2</span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>          y8 <span class="ot">=</span> y4 <span class="op">*</span> y4</span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>      <span class="kw">in</span> y8 <span class="op">*</span> y2</span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# INLINE g #-}</span></span></code></pre></div>
<p>Here is the benchmark result with Apple M4 Pro:</p>
<pre><code>$ cabal bench -w ghc-9.8.4 --ghc-options=-fllvm -O2
benchmarking Float/f/scalar
time                 3.206 μs   (3.200 μs .. 3.211 μs)
                     1.000 R²   (1.000 R² .. 1.000 R²)
mean                 3.207 μs   (3.201 μs .. 3.215 μs)
std dev              22.70 ns   (15.40 ns .. 37.09 ns)

benchmarking Float/f/vector
time                 892.3 ns   (889.6 ns .. 894.8 ns)
                     1.000 R²   (1.000 R² .. 1.000 R²)
mean                 893.0 ns   (890.9 ns .. 894.5 ns)
std dev              6.179 ns   (4.750 ns .. 7.933 ns)

benchmarking Float/f/vector (unified)
time                 897.8 ns   (895.3 ns .. 900.2 ns)
                     1.000 R²   (1.000 R² .. 1.000 R²)
mean                 898.7 ns   (896.3 ns .. 902.2 ns)
std dev              9.800 ns   (6.691 ns .. 16.75 ns)

benchmarking Float/g/scalar
time                 3.215 μs   (3.211 μs .. 3.219 μs)
                     1.000 R²   (1.000 R² .. 1.000 R²)
mean                 3.213 μs   (3.210 μs .. 3.220 μs)
std dev              15.61 ns   (8.731 ns .. 28.17 ns)

benchmarking Float/g/vector
time                 893.0 ns   (890.7 ns .. 895.9 ns)
                     1.000 R²   (1.000 R² .. 1.000 R²)
mean                 894.2 ns   (892.1 ns .. 896.7 ns)
std dev              7.870 ns   (6.011 ns .. 11.68 ns)

benchmarking Float/g/vector (unified)
time                 901.2 ns   (897.6 ns .. 904.0 ns)
                     1.000 R²   (1.000 R² .. 1.000 R²)
mean                 898.0 ns   (895.9 ns .. 899.9 ns)
std dev              6.522 ns   (5.186 ns .. 8.885 ns)

benchmarking Double/f/scalar
time                 3.185 μs   (3.179 μs .. 3.193 μs)
                     1.000 R²   (1.000 R² .. 1.000 R²)
mean                 3.188 μs   (3.184 μs .. 3.199 μs)
std dev              21.43 ns   (11.81 ns .. 36.86 ns)

benchmarking Double/f/vector
time                 3.649 μs   (3.621 μs .. 3.674 μs)
                     1.000 R²   (0.999 R² .. 1.000 R²)
mean                 3.662 μs   (3.640 μs .. 3.674 μs)
std dev              54.79 ns   (39.52 ns .. 73.07 ns)
variance introduced by outliers: 13% (moderately inflated)

benchmarking Double/f/vector (unified)
time                 3.671 μs   (3.652 μs .. 3.688 μs)
                     1.000 R²   (1.000 R² .. 1.000 R²)
mean                 3.672 μs   (3.654 μs .. 3.683 μs)
std dev              45.43 ns   (27.65 ns .. 83.19 ns)

benchmarking Double/g/scalar
time                 3.221 μs   (3.214 μs .. 3.228 μs)
                     1.000 R²   (1.000 R² .. 1.000 R²)
mean                 3.220 μs   (3.215 μs .. 3.225 μs)
std dev              17.02 ns   (12.05 ns .. 28.72 ns)

benchmarking Double/g/vector
time                 1.658 μs   (1.656 μs .. 1.662 μs)
                     1.000 R²   (1.000 R² .. 1.000 R²)
mean                 1.662 μs   (1.659 μs .. 1.673 μs)
std dev              16.55 ns   (4.710 ns .. 36.25 ns)

benchmarking Double/g/vector (unified)
time                 1.661 μs   (1.658 μs .. 1.664 μs)
                     1.000 R²   (1.000 R² .. 1.000 R²)
mean                 1.658 μs   (1.656 μs .. 1.662 μs)
std dev              9.381 ns   (4.704 ns .. 17.62 ns)</code></pre>
<p>The <code>Float</code> code runs 3.206/0.8923≈3.59 times faster if vectorized.
Good.</p>
<p>For the <code>Double</code> code, <code>f</code> does not run faster.
On the other hand, <code>g</code> runs 3.221/1.658≈1.94 times faster if vectorized.
Nice.</p>
<p>Here is results from another CPU, Ryzen 9 7940HS (Zen 4), run on Ubuntu on WSL2:</p>
<pre><code>$ cabal bench -w ghc-9.8.4 --ghc-options=-fllvm -O2
benchmarking Float/f/scalar
time                 4.190 μs   (4.154 μs .. 4.231 μs)
                     0.999 R²   (0.999 R² .. 1.000 R²)
mean                 4.201 μs   (4.172 μs .. 4.261 μs)
std dev              139.4 ns   (77.76 ns .. 238.0 ns)
variance introduced by outliers: 42% (moderately inflated)

benchmarking Float/f/vector
time                 1.288 μs   (1.276 μs .. 1.302 μs)
                     0.999 R²   (0.999 R² .. 1.000 R²)
mean                 1.293 μs   (1.282 μs .. 1.308 μs)
std dev              42.72 ns   (30.33 ns .. 65.09 ns)
variance introduced by outliers: 45% (moderately inflated)

benchmarking Float/f/vector (unified)
time                 1.290 μs   (1.279 μs .. 1.301 μs)
                     0.999 R²   (0.999 R² .. 1.000 R²)
mean                 1.291 μs   (1.280 μs .. 1.304 μs)
std dev              42.05 ns   (30.81 ns .. 60.24 ns)
variance introduced by outliers: 45% (moderately inflated)

benchmarking Float/g/scalar
time                 4.187 μs   (4.148 μs .. 4.235 μs)
                     0.999 R²   (0.999 R² .. 1.000 R²)
mean                 4.200 μs   (4.165 μs .. 4.257 μs)
std dev              149.5 ns   (109.6 ns .. 213.1 ns)
variance introduced by outliers: 46% (moderately inflated)

benchmarking Float/g/vector
time                 1.359 μs   (1.350 μs .. 1.370 μs)
                     1.000 R²   (0.999 R² .. 1.000 R²)
mean                 1.363 μs   (1.355 μs .. 1.375 μs)
std dev              32.39 ns   (21.39 ns .. 48.15 ns)
variance introduced by outliers: 30% (moderately inflated)

benchmarking Float/g/vector (unified)
time                 1.366 μs   (1.354 μs .. 1.378 μs)
                     0.999 R²   (0.999 R² .. 1.000 R²)
mean                 1.365 μs   (1.356 μs .. 1.378 μs)
std dev              35.55 ns   (26.86 ns .. 46.75 ns)
variance introduced by outliers: 34% (moderately inflated)

benchmarking Double/f/scalar
time                 4.214 μs   (4.183 μs .. 4.246 μs)
                     0.999 R²   (0.999 R² .. 1.000 R²)
mean                 4.225 μs   (4.195 μs .. 4.280 μs)
std dev              131.8 ns   (87.25 ns .. 222.4 ns)
variance introduced by outliers: 39% (moderately inflated)

benchmarking Double/f/vector
time                 2.159 μs   (2.140 μs .. 2.182 μs)
                     0.999 R²   (0.998 R² .. 0.999 R²)
mean                 2.208 μs   (2.180 μs .. 2.253 μs)
std dev              116.2 ns   (77.12 ns .. 170.5 ns)
variance introduced by outliers: 67% (severely inflated)

benchmarking Double/f/vector (unified)
time                 2.146 μs   (2.131 μs .. 2.165 μs)
                     0.999 R²   (0.999 R² .. 1.000 R²)
mean                 2.153 μs   (2.138 μs .. 2.172 μs)
std dev              57.85 ns   (44.10 ns .. 86.56 ns)
variance introduced by outliers: 34% (moderately inflated)

benchmarking Double/g/scalar
time                 4.192 μs   (4.159 μs .. 4.225 μs)
                     0.999 R²   (0.999 R² .. 1.000 R²)
mean                 4.195 μs   (4.171 μs .. 4.234 μs)
std dev              100.5 ns   (76.68 ns .. 130.0 ns)
variance introduced by outliers: 27% (moderately inflated)

benchmarking Double/g/vector
time                 2.187 μs   (2.171 μs .. 2.205 μs)
                     0.999 R²   (0.999 R² .. 1.000 R²)
mean                 2.192 μs   (2.177 μs .. 2.215 μs)
std dev              61.57 ns   (44.70 ns .. 88.71 ns)
variance introduced by outliers: 36% (moderately inflated)

benchmarking Double/g/vector (unified)
time                 2.181 μs   (2.159 μs .. 2.207 μs)
                     0.999 R²   (0.999 R² .. 1.000 R²)
mean                 2.193 μs   (2.176 μs .. 2.225 μs)
std dev              75.01 ns   (45.34 ns .. 123.4 ns)
variance introduced by outliers: 46% (moderately inflated)</code></pre>
<p>The <code>Float</code> code runs 4.190/1.288≈3.25 times faster if vectorized.</p>
<p>For the <code>Double</code> code, <code>f</code> does not run faster.
On the other hand, <code>g</code> runs 4.192/2.181≈1.92 times faster if vectorized.</p>
<p>Let’s try NCG backend from GHC 9.12.</p>
<pre><code>$ cabal bench -w ghc-9.12.1 --builddir=dist-ncg -O2 --allow-newer
benchmarking Float/f/scalar
time                 38.18 μs   (38.00 μs .. 38.37 μs)
                     1.000 R²   (1.000 R² .. 1.000 R²)
mean                 38.00 μs   (37.80 μs .. 38.19 μs)
std dev              670.4 ns   (522.7 ns .. 874.4 ns)
variance introduced by outliers: 14% (moderately inflated)

benchmarking Float/f/vector
time                 7.118 μs   (7.049 μs .. 7.184 μs)
                     0.999 R²   (0.999 R² .. 1.000 R²)
mean                 7.121 μs   (7.080 μs .. 7.178 μs)
std dev              170.4 ns   (140.2 ns .. 209.8 ns)
variance introduced by outliers: 26% (moderately inflated)

benchmarking Float/f/vector (unified)
time                 7.151 μs   (7.106 μs .. 7.195 μs)
                     1.000 R²   (1.000 R² .. 1.000 R²)
mean                 7.131 μs   (7.091 μs .. 7.177 μs)
std dev              147.8 ns   (123.3 ns .. 186.5 ns)
variance introduced by outliers: 21% (moderately inflated)

benchmarking Float/g/scalar
time                 13.76 μs   (13.63 μs .. 13.89 μs)
                     0.999 R²   (0.999 R² .. 1.000 R²)
mean                 13.39 μs   (13.22 μs .. 13.54 μs)
std dev              539.9 ns   (434.0 ns .. 699.9 ns)
variance introduced by outliers: 48% (moderately inflated)

benchmarking Float/g/vector
time                 1.397 μs   (1.384 μs .. 1.412 μs)
                     0.999 R²   (0.999 R² .. 1.000 R²)
mean                 1.395 μs   (1.384 μs .. 1.408 μs)
std dev              35.98 ns   (29.38 ns .. 44.60 ns)
variance introduced by outliers: 33% (moderately inflated)

benchmarking Float/g/vector (unified)
time                 1.199 μs   (1.187 μs .. 1.210 μs)
                     0.999 R²   (0.999 R² .. 1.000 R²)
mean                 1.195 μs   (1.186 μs .. 1.205 μs)
std dev              30.76 ns   (26.36 ns .. 35.65 ns)
variance introduced by outliers: 34% (moderately inflated)

benchmarking Double/f/scalar
time                 38.59 μs   (38.38 μs .. 38.83 μs)
                     1.000 R²   (1.000 R² .. 1.000 R²)
mean                 38.65 μs   (38.46 μs .. 38.91 μs)
std dev              699.1 ns   (550.4 ns .. 890.0 ns)
variance introduced by outliers: 14% (moderately inflated)

benchmarking Double/f/vector
time                 8.237 μs   (8.185 μs .. 8.302 μs)
                     1.000 R²   (0.999 R² .. 1.000 R²)
mean                 8.281 μs   (8.229 μs .. 8.349 μs)
std dev              195.3 ns   (145.6 ns .. 255.1 ns)
variance introduced by outliers: 26% (moderately inflated)

benchmarking Double/f/vector (unified)
time                 8.267 μs   (8.208 μs .. 8.332 μs)
                     1.000 R²   (0.999 R² .. 1.000 R²)
mean                 8.291 μs   (8.233 μs .. 8.363 μs)
std dev              205.6 ns   (162.1 ns .. 272.7 ns)
variance introduced by outliers: 27% (moderately inflated)

benchmarking Double/g/scalar
time                 13.91 μs   (13.79 μs .. 14.03 μs)
                     0.999 R²   (0.998 R² .. 0.999 R²)
mean                 13.64 μs   (13.47 μs .. 13.77 μs)
std dev              523.9 ns   (437.4 ns .. 658.1 ns)
variance introduced by outliers: 46% (moderately inflated)

benchmarking Double/g/vector
time                 2.667 μs   (2.640 μs .. 2.701 μs)
                     0.999 R²   (0.999 R² .. 0.999 R²)
mean                 2.690 μs   (2.671 μs .. 2.711 μs)
std dev              67.58 ns   (53.11 ns .. 86.86 ns)
variance introduced by outliers: 31% (moderately inflated)

benchmarking Double/g/vector (unified)
time                 2.267 μs   (2.241 μs .. 2.298 μs)
                     0.999 R²   (0.999 R² .. 1.000 R²)
mean                 2.264 μs   (2.246 μs .. 2.288 μs)
std dev              68.17 ns   (54.30 ns .. 86.66 ns)
variance introduced by outliers: 39% (moderately inflated)</code></pre>
<p><code>Float/f</code> runs 38.18/7.118≈5.36 times faster if vectorized.
<code>Float/g</code> runs 13.76/1.199≈11.5 times faster if vectorized.</p>
<p><code>Double/f</code> runs 38.59/8.237≈4.68 times faster if vectorized.
<code>Double/g</code> runs 13.91/2.267≈6.14 times faster if vectorized.</p>
<p>With NCG backend, the degree of improvement is more than the number of parallelization (4 or 2).
Maybe the scalar code is not optimized well.</p>
<h2 id="using-cpu-features-conditionally">Using CPU Features Conditionally</h2>
<p>We have some SIMD support in x86 NCG backend, and we can write a library for vectorization.
Is that all?
No, we have another problem.</p>
<p>SSE2 is always available on x86-64, but other extensions like SSE4.1, AVX2, and AVX-512 are not available on all CPUs (or emulators).
Therefore, if a program wants to use AVX2, either it should be built exclusively for CPUs supporting AVX2, or conditionally use AVX2 by looking at CPUID.
Currently, GHC supports only the first option, via flags like <code>-mavx2</code>.</p>
<p>This may be fine for programs that only need to run on a specific CPU, but not for libraries that need to run on many CPUs.</p>
<p>Therefore, it is desirable to have a mechanism to enable a CPU feature on a function (or execution path) basis rather than on a per-module basis, and a mechanism to switch the code to be executed by looking at CPUID.</p>
<p>As a prior art, GNU C has an attribute for selecting the target: <code>__attribute__((target("avx2")))</code>.
Therefore, we could have something similar like:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# TARGET &quot;avx2&quot; #-}</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="ot">foo ::</span> <span class="dt">X8</span> <span class="dt">Int32</span> <span class="ot">-&gt;</span> <span class="dt">X8</span> <span class="dt">Int32</span> <span class="ot">-&gt;</span> <span class="dt">X8</span> <span class="dt">Int32</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>foo x y <span class="ot">=</span> <span class="dv">2</span> <span class="op">*</span> x <span class="op">+</span> y</span></code></pre></div>
<p>There is a related issue:
<a href="https://gitlab.haskell.org/ghc/ghc/-/issues/15876">#15876: Function versioning instead of compilation flags… · Issues · Glasgow Haskell Compiler / GHC · GitLab</a></p>
<p>Now, I’m wondering if <em>nullary type classes</em> (or <em>nullary type families</em>) could be used to represent CPU features.
I mean, something like</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Using a nullary type class</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">HasAVX2</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- -mavx2 would make the constraint `HasAVX2` available on that module</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>plusInt32X8<span class="op">#</span><span class="ot"> ::</span> <span class="dt">HasAVX2</span> <span class="ot">=&gt;</span> <span class="dt">Int32X8</span><span class="op">#</span> <span class="ot">-&gt;</span> <span class="dt">Int32X8</span><span class="op">#</span> <span class="ot">-&gt;</span> <span class="dt">Int32X8</span><span class="op">#</span></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Dict</span><span class="ot"> ::</span> <span class="dt">Constraint</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Dict</span> c <span class="ot">=</span> c <span class="ot">=&gt;</span> <span class="dt">Dict</span></span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a><span class="co">-- modules that don&#39;t have -mavx2 enabled can use `detectAVX2` to conditionally enable AVX2</span></span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a><span class="ot">detectAVX2 ::</span> <span class="dt">Maybe</span> (<span class="dt">Dict</span> <span class="dt">HasAVX2</span>)</span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true" tabindex="-1"></a>detectAVX2 <span class="ot">=</span> <span class="op">...</span> <span class="co">-- use CPUID to detect AVX2</span></span></code></pre></div>
<p>or</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Using a nullary type family</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">AVX2</span><span class="ot"> ::</span> <span class="dt">Bool</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- -mavx2 would make the equation `AVX2 ~ True` available on that module</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>plusInt32X8<span class="op">#</span><span class="ot"> ::</span> <span class="dt">AVX2</span> <span class="op">~</span> <span class="dt">True</span> <span class="ot">=&gt;</span> <span class="dt">Int32X8</span><span class="op">#</span> <span class="ot">-&gt;</span> <span class="dt">Int32X8</span><span class="op">#</span> <span class="ot">-&gt;</span> <span class="dt">Int32X8</span><span class="op">#</span></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">SBool</span> (<span class="ot">b ::</span> <span class="dt">Bool</span>) <span class="kw">where</span></span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">STrue</span><span class="ot"> ::</span> <span class="dt">SBool</span> <span class="dt">True</span></span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a>  <span class="dt">SFalse</span><span class="ot"> ::</span> <span class="dt">SBool</span> <span class="dt">False</span></span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a><span class="co">-- modules that don&#39;t have -mavx2 enabled can use `detectAVX2` to conditionally enable AVX2</span></span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a><span class="ot">detectAVX2 ::</span> <span class="dt">SBool</span> <span class="dt">AVX2</span></span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true" tabindex="-1"></a>detectAVX2 <span class="ot">=</span> <span class="op">...</span> <span class="co">-- use CPUID to detect AVX2</span></span></code></pre></div>
<p>This is just an idea (I’m no expert on GHC’s internals), and I don’t know if it works well when you want cross-platform support (x86, AArch64, RISC-V, …).</p>
<h2 id="conclusion">Conclusion</h2>
<p>Although not complete, there is some progress on GHC’s SIMD support.</p>
<p>I plan to continue improving the SIMD support during my spare time.
I’m also working on a library to wrap GHC’s SIMD primitives.</p>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>If you are interested, take a look at this ticket: <a href="https://gitlab.haskell.org/ghc/ghc/-/issues/25030">#25030: Meta-issue for SIMD support in the native code generator · Issues · Glasgow Haskell Compiler / GHC · GitLab</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>]]></description>
    <pubDate>Mon, 13 Jan 2025 00:00:00 UT</pubDate>
    <guid>https://minoki.github.io/posts/2025-01-13-ghc-simd.html</guid>
    <dc:creator>Arata Mizuki</dc:creator>
</item>
<item>
    <title>How to use GHC's LLVM backend</title>
    <link>https://minoki.github.io/posts/2025-01-06-ghc-llvm-backend.html</link>
    <description><![CDATA[<p>Japanese version: <a href="https://zenn.dev/mod_poppo/articles/ghc-llvm-backend">GHCのLLVMバックエンドの使い方</a> <em>This article was translated from Japanese with help of AI. Of course, the translation was checked and corrected by the human.</em></p>
<hr />
<p>GHC is a compiler capable of generating native code.
It provides three methods for generating native code: its own NCG (Native Code Generator) backend, the LLVM backend, and the via-C backend that generates code via C sources.</p>
<p>Typically, the NCG backend is used to generate code for x86 or AArch64, but there may be situations where you want to use the LLVM backend.
This article explains how to enable and use the LLVM backend in GHC.</p>
<!-- GHC introduced the LLVM backend in version 7.0, released in 2010. -->
<p>Here are the features of the LLVM backend compared to the NCG backend:</p>
<ul>
<li>Supports more architectures: As of this writing, ARM, AArch64, LoongArch, RISC-V, System Z, x86, and x86-64. (Some of these are also supported by NCG, but others are only supported via the LLVM backend.)</li>
<li>Supports SIMD primitives (Though NCG supports some SIMD primitives for x86-64 starting from GHC 9.12, it is still in development.)</li>
<li>Leverages optimizations implemented in LLVM.</li>
</ul>
<p>For certain targets, using the LLVM backend is mandatory.
For example:</p>
<ul>
<li>To generate code for AArch64 with GHC &lt;= 9.0, you need the LLVM backend.</li>
<li>Similarly, generating RISC-V code with GHC &lt;= 9.10 requires the LLVM backend.</li>
</ul>
<p>Note: The sections “Installing LLVM” and “Configuring GHC to Use LLVM” do not apply to Windows. For Windows-specific instructions, see the “For Windows” section below.</p>
<h2 id="installing-llvm">Installing LLVM</h2>
<p>For non-Windows systems, LLVM is not bundled with GHC and must be installed separately using your system’s package manager.</p>
<p>The version of LLVM you need depends on the GHC version.
The following table summarizes the compatibility:</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr>
<th style="text-align: left;">GHC</th>
<th style="text-align: left;">LLVM</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">GHC 8.10.7</td>
<td style="text-align: left;">LLVM &gt;= 9 &amp;&amp; &lt;= 12</td>
</tr>
<tr>
<td style="text-align: left;">GHC 9.0.2</td>
<td style="text-align: left;">LLVM &gt;= 9 &amp;&amp; &lt;= 12</td>
</tr>
<tr>
<td style="text-align: left;">GHC 9.2.8</td>
<td style="text-align: left;">LLVM &gt;= 9 &amp;&amp; &lt;= 12</td>
</tr>
<tr>
<td style="text-align: left;">GHC 9.4.8</td>
<td style="text-align: left;">LLVM &gt;= 10 &amp;&amp; &lt;= 13 (if you are using <code>-mavx</code>, you need LLVM &lt;= 12)</td>
</tr>
<tr>
<td style="text-align: left;">GHC 9.6</td>
<td style="text-align: left;">LLVM &gt;= 11 &amp;&amp; &lt;= 15 (if you are using <code>-mavx</code>, you need LLVM &lt;= 12)</td>
</tr>
<tr>
<td style="text-align: left;">GHC 9.8</td>
<td style="text-align: left;">LLVM &gt;= 11 &amp;&amp; &lt;= 15 (if you are using <code>-mavx</code>, you need LLVM &lt;= 12)</td>
</tr>
<tr>
<td style="text-align: left;">GHC 9.10</td>
<td style="text-align: left;">LLVM &gt;= 13 &amp;&amp; &lt;= 15</td>
</tr>
<tr>
<td style="text-align: left;">GHC 9.12</td>
<td style="text-align: left;">LLVM &gt;= 13 &amp;&amp; &lt;= 19</td>
</tr>
</tbody>
</table>
<p>Note: Use LLVM 12 for GHC &lt;= 9.8 if you plan to use the <code>-mavx</code> option (<a href="https://gitlab.haskell.org/ghc/ghc/-/issues/23870">GHC #23870</a>).</p>
<p>Here, I describe the procedures to install LLVM 15.</p>
<p>For Ubuntu or similar systems using <code>apt</code>:</p>
<pre><code>$ sudo apt install llvm-15 clang-15</code></pre>
<p>For macOS using Homebrew:</p>
<pre><code>$ brew install llvm@15</code></pre>
<p>For macOS using MacPorts:</p>
<pre><code>$ sudo port install llvm-15 clang-15</code></pre>
<p>Among the libraries and commands provided by LLVM, the ones required by GHC are these:</p>
<ul>
<li>The <code>opt</code> command: The optimizer for LLVM IR.</li>
<li>The <code>llc</code> command: The tool to generate assembly output from LLVM IR.</li>
<li>The <code>clang</code> command: GHC 9.10+ uses it as an assembler.</li>
</ul>
<p>Let’s see where these commands are located.</p>
<p>On Ubuntu, commands have the suffix <code>-15</code>:</p>
<pre><code>$ which opt-15 llc-15 clang-15
/usr/bin/opt-15
/usr/bin/llc-15
/usr/bin/clang-15</code></pre>
<p>Alternatively, <code>/usr/lib/llvm-15/bin</code> contains the commands without suffix:</p>
<pre><code>$ ls /usr/lib/llvm-15/bin/{opt,llc,clang}
/usr/lib/llvm-15/bin/clang
/usr/lib/llvm-15/bin/llc
/usr/lib/llvm-15/bin/opt</code></pre>
<p>On macOS with Homebrew, the commands are in <code>$(brew --prefix llvm@15)/bin</code>:</p>
<pre><code>$ ls $(brew --prefix llvm@15)/bin/{opt,llc,clang}
/opt/homebrew/opt/llvm@15/bin/clang
/opt/homebrew/opt/llvm@15/bin/llc
/opt/homebrew/opt/llvm@15/bin/opt</code></pre>
<p>On macOS with MacPorts, commands have the suffix <code>-mp-15</code>:</p>
<pre><code>$ which opt-mp-15 llc-mp-15 clang-mp-15
/opt/local/bin/opt-mp-15
/opt/local/bin/llc-mp-15
/opt/local/bin/clang-mp-15</code></pre>
<p>Alternatively, <code>/opt/local/libexec/llvm-15/bin</code> contains the commands without suffix:</p>
<pre><code>$ ls /opt/local/libexec/llvm-15/bin/{opt,llc,clang}
/opt/local/libexec/llvm-15/bin/clang
/opt/local/libexec/llvm-15/bin/llc
/opt/local/libexec/llvm-15/bin/opt</code></pre>
<p>Adding the directory containing the suffix-less commands to your PATH makes it easier for GHC to locate them, which is convenient.
However, since different versions of GHC may require different versions of LLVM, I do not recommend adding the suffix-less commands to your PATH if you need to manage multiple GHC/LLVM versions simultaneously.</p>
<h2 id="configuring-ghc-to-use-llvm">Configuring GHC to Use LLVM</h2>
<p>GHC needs to know the location of the LLVM tools (<code>opt</code>, <code>llc</code>, and <code>clang</code>).
There are two ways to configure this:</p>
<ul>
<li>Specify the paths each time you compile.</li>
<li>Set the paths when installing GHC.</li>
</ul>
<h3 id="specify-paths-at-compile-time">Specify Paths at Compile Time</h3>
<p>Use the <code>-pgmlo</code>, <code>-pgmlc</code>, and <code>-pgmlas</code> flags to specify the locations of <code>opt</code>, <code>llc</code>, and <code>clang</code>, respectively.
For example, if you want to use GHC 9.12.1 with LLVM 15 installed by Homebrew, you type:</p>
<pre><code>$ ghc-9.12.1 -fllvm -pgmlo $(brew --prefix llvm@15)/bin/opt \
    -pgmlc $(brew --prefix llvm@15)/bin/llc \
    -pgmlas $(brew --prefix llvm@15)/bin/clang Main.hs</code></pre>
<h3 id="configure-paths-during-ghc-installation">Configure Paths During GHC Installation</h3>
<p>If you specify the location of LLVM tools during GHC installation, you won’t need to specify options like <code>-pgmlo</code> each time.</p>
<p>First, if the LLVM tools are in a directory included in your PATH, and the command names follow one of the formats below:</p>
<pre><code>opt-15 opt-15.0 opt15 opt
llc-15 llc-15.0 llc15 llc
clang-15 clang-15.0 clang15 clang</code></pre>
<p>GHC’s <code>configure</code> command will automatically detect and record the LLVM toolchain names during installation.</p>
<p>If LLVM wasn’t installed at the time of GHC installation, you will need to reinstall or reconfigure GHC after installing LLVM.
For example. using GHCup, you can run:</p>
<pre><code>$ ghcup install ghc 9.12.1 --force</code></pre>
<p>With Stack, you can use:</p>
<pre><code>$ stack setup 9.12.1 --reinstall</code></pre>
<p>If the LLVM tools are not in the PATH or their names are non-standard (e.g. when using Homebrew or MacPorts), you need to manually specify the locations of <code>opt</code>, <code>llc</code>, and <code>clang</code> when running GHC’s <code>configure</code> command.
This is done by setting the <code>OPT</code>, <code>LLC</code>, and <code>LLVMAS</code> environment variables.</p>
<p>For GHCup, the process looks like this:</p>
<pre><code>$ # Using Homebrew
$ env OPT=$(brew --prefix llvm@15)/bin/opt \
      LLC=$(brew --prefix llvm@15)/bin/llc \
      LLVMAS=$(brew --prefix llvm@15)/bin/clang \
      ghcup install ghc 9.12.1 --force

$ # Using MacPorts
$ env OPT=opt-mp-15 LLC=llc-mp-15 LLVMAS=clang-mp-15 \
      ghcup install ghc 9.12.1 --force</code></pre>
<p>If you installed GHC using Stack, follow these steps:</p>
<pre><code>$ # Using Homebrew
$ env OPT=$(brew --prefix llvm@15)/bin/opt \
      LLC=$(brew --prefix llvm@15)/bin/llc \
      LLVMAS=$(brew --prefix llvm@15)/bin/clang \
      stack setup 9.12.1 --reinstall

$ # Using MacPorts
$ env OPT=opt-mp-15 LLC=llc-mp-15 LLVMAS=clang-mp-15 \
      stack setup 9.12.1 --reinstall</code></pre>
<p>To install GHC directly from a tarball:</p>
<pre><code>$ curl -LO https://downloads.haskell.org/~ghc/9.12.1/ghc-9.12.1-aarch64-apple-darwin.tar.xz
$ tar xf ghc-9.12.1-aarch64-apple-darwin.tar.xz
$ cd ghc-9.12.1-aarch64-apple-darwin

$ # Using Homebrew
$ env OPT=$(brew --prefix llvm@15)/bin/opt \
      LLC=$(brew --prefix llvm@15)/bin/llc \
      LLVMAS=$(brew --prefix llvm@15)/bin/clang \
      ./configure --prefix=/opt/ghc-9.12.1

$ # Using MacPorts
$ env OPT=opt-mp-15 LLC=llc-mp-15 LLVMAS=clang-mp-15 \
      ./configure --prefix=/opt/ghc-9.12.1

$ sudo make install</code></pre>
<p>The names of the detected or manually specified LLVM commands (<code>opt</code>, <code>llc</code>, <code>clang</code>) are recorded in the <code>lib/settings</code> file.
You can check the content like this:</p>
<pre><code>$ # For GHCup
$ grep LLVM ~/.ghcup/ghc/9.12.1/lib/ghc-9.12.1/lib/settings
,(&quot;LLVM target&quot;, &quot;arm64-apple-darwin&quot;)
,(&quot;LLVM llc command&quot;, &quot;/opt/homebrew/opt/llvm@15/bin/llc&quot;)
,(&quot;LLVM opt command&quot;, &quot;/opt/homebrew/opt/llvm@15/bin/opt&quot;)
,(&quot;LLVM llvm-as command&quot;, &quot;/opt/homebrew/opt/llvm@15/bin/clang&quot;)

$ # For Stack
$ grep LLVM ~/.stack/programs/aarch64-osx/ghc-9.12.1/lib/ghc-9.12.1/lib/settings
,(&quot;LLVM target&quot;, &quot;arm64-apple-darwin&quot;)
,(&quot;LLVM llc command&quot;, &quot;/opt/homebrew/opt/llvm@15/bin/llc&quot;)
,(&quot;LLVM opt command&quot;, &quot;/opt/homebrew/opt/llvm@15/bin/opt&quot;)
,(&quot;LLVM llvm-as command&quot;, &quot;/opt/homebrew/opt/llvm@15/bin/clang&quot;)</code></pre>
<p>Note:
If you temporarily add <code>PATH=$(brew --prefix llvm@15)/bin:$PATH</code> to include the LLVM commands during setup, only the command names (e.g. <code>opt</code>) are recorded in the <code>lib/settings</code> file instead of the full paths.
For this reason, it is better to use environment variables like <code>OPT</code> when specifying the locations of the commands.</p>
<h2 id="for-windows">For Windows</h2>
<p>On Windows, GHC includes LLVM starting from version 9.4.
With GHC 9.12 and later, the LLVM bundled with GHC is automatically used.</p>
<p>However, for GHC versions &lt;= 9.10, attempting to use the LLVM backend with floating-point numbers can lead to linker errors, making it effectively unusable.
For more details, refer to <a href="https://gitlab.haskell.org/ghc/ghc/-/issues/22487">GHC #22487</a>.</p>
<h2 id="using-the-llvm-backend">Using the LLVM Backend</h2>
<p>If the setup is successful, you can use the LLVM backend by passing the <code>-fllvm</code> option to GHC:</p>
<pre><code>$ ghc -fllvm hello.hs</code></pre>
<p>Of course, if you chose to the “specify paths at compile time” method, you’ll also need to provide options such as <code>-pgmlo</code> each time.</p>
<h2 id="using-the-llvm-backend-in-github-actions">Using the LLVM Backend in GitHub Actions</h2>
<p>There may be scenarios where you want to enable the LLVM backend in GitHub Actions.
With the knowledge gained so far, configuring the LLVM backend in GitHub Actions should not be difficult.
For a practical example, see <a href="https://github.com/minoki/ghc-llvm-backend-test/blob/main/.github/workflows/build.yaml">ghc-llvm-backend-test/.github/workflows/build.yaml</a>.</p>
<p>One point to note is that the runner image might already include a version of GHC.
In such cases, you need to pass the <code>--force</code> option to GHCup.
Since the current <code>haskell-actions/setup</code> does not support passing the <code>--force</code> option, you can either install GHCup directly or use the <a href="https://github.com/marketplace/actions/ghcup-setup">haskell/ghcup-setup</a> action.</p>
<h2 id="known-issues-with-the-llvm-backend">Known Issues with the LLVM Backend</h2>
<p>Here are some known issues related to the LLVM backend, including ones already mentioned:</p>
<ul>
<li><p>GHC &lt;= 9.8 &amp;&amp; LLVM &gt;= 13: <a href="https://gitlab.haskell.org/ghc/ghc/-/issues/23870">#23870: LLVM 13+ doesn’t recognize <code>-stack-alignment</code> option · Issues · Glasgow Haskell Compiler / GHC · GitLab</a> This issue arises when the <code>-mavx</code> option is specified.</p></li>
<li><p>GHC &lt;= 9.10 on Windows: <a href="https://gitlab.haskell.org/ghc/ghc/-/issues/22487">#22487: Link error when using LLVM backend on Windows: undefined symbol: <code>_fltused</code> · Issues · Glasgow Haskell Compiler / GHC · GitLab</a> This occurs whe floating-point numbers are used.</p></li>
<li><p>GHC 9.10.1 on macOS: <a href="https://gitlab.haskell.org/ghc/ghc/-/issues/24999">#24999: LLVM version detection logic in configure doesn’t work on macOS · Issues · Glasgow Haskell Compiler / GHC · GitLab</a></p></li>
</ul>
<h2 id="conclusion">Conclusion</h2>
<p>Start using GHC’s LLVM backend to take full advantage of its optimizations and architecture support.
Happy coding!</p>]]></description>
    <pubDate>Mon, 06 Jan 2025 00:00:00 UT</pubDate>
    <guid>https://minoki.github.io/posts/2025-01-06-ghc-llvm-backend.html</guid>
    <dc:creator>Arata Mizuki</dc:creator>
</item>
<item>
    <title>Playing with Visible Forall in GHC 9.10</title>
    <link>https://minoki.github.io/posts/2024-05-11-playing-with-visible-forall.html</link>
    <description><![CDATA[<p><em>Japanese version</em>: <a href="https://zenn.dev/mod_poppo/articles/playing-with-visible-forall">GHC 9.10で実装された可視なforallで遊ぶ</a></p>
<p>Today, GHC 9.10.1 is released.
One of the new features is “visible forall”, or <code>RequiredTypeArguments</code> extension.
In this article, I will play with this new feature.</p>
<p>The official documents of this feature are these:</p>
<ul>
<li><a href="https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0281-visible-forall.rst">ghc-proposals/proposals/0281-visible-forall.rst at master · ghc-proposals/ghc-proposals</a></li>
<li><a href="https://downloads.haskell.org/ghc/9.10.1/docs/users_guide/exts/required_type_arguments.html">6.4.18. Required type arguments — Glasgow Haskell Compiler 9.10.1 User’s Guide</a></li>
</ul>
<h2 id="basics-the-identity-function">Basics: The identity function</h2>
<p>The simplest example would be the variant of <code>id</code> function that takes the type explicitly.
The ordinary <code>id</code> function and the variant of <code>id</code> function with visible <code>forall</code> can each be written as follows:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE RequiredTypeArguments #-}</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- From User&#39;s Guide:</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- The ordinary id function</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="fu">id</span><span class="ot"> ::</span> <span class="kw">forall</span> a<span class="op">.</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="fu">id</span> x <span class="ot">=</span> x</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="co">-- The id function with visible forall</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="ot">id_vdq ::</span> <span class="kw">forall</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>id_vdq a x <span class="ot">=</span> x</span></code></pre></div>
<p>Let’s try them with GHCi:</p>
<pre><code>ghci&gt; :set +t
ghci&gt; id 42  -- Let GHC infer the type
42
it :: Num a =&gt; a
ghci&gt; id @Int 42  -- Supply the type explicitly
42
it :: Int
ghci&gt; id_vdq _ 42  -- Let GHC infer the type
42
it :: Num w =&gt; w
ghci&gt; id_vdq Int 42  -- Supply the type explicitly (note that there&#39;s no `@`!)
42
it :: Int</code></pre>
<p>So, by declaraing a function with <code>forall -&gt;</code>, you can pass the type without using <code>@</code>.</p>
<p>Note that if the same notation is used for a term and a type, the term interpretation takes precedence.
Let’s pass the <code>[Int]</code> type:</p>
<pre><code>ghci&gt; id_vdq [Int] [42]
&lt;interactive&gt;:37:8: error: [GHC-83865]
    • Expected a type, but ‘[Int]’ has kind ‘[*]’
    • In the type ‘[Int]’
      In the expression: id_vdq [Int] [42]
      In an equation for ‘it’: it = id_vdq [Int] [42]</code></pre>
<p>An error occurs because <code>[Int]</code> is interpreted as “a type-level list with <code>Int</code> as an element” instead of “the type of a list consisting of <code>Int</code>”.
There are two ways around this problem.</p>
<p>The first is to use a <code>type</code> expression, which will be available with the <code>ExplicitNamespaces</code> extension.</p>
<pre><code>ghci&gt; :set -XExplicitNamespaces 
ghci&gt; id_vdq (type [Int]) [42]
[42]
it :: [Int]</code></pre>
<p>The other is to stop using the same notation for terms and types.
For list and tuple types, the <code>Prelude.Experimental</code> module provides aliases such as <code>List</code> and <code>Tuple2</code>.</p>
<pre><code>ghci&gt; :m + Prelude.Experimental
ghci&gt; id_vdq (List Int) [42]
[42]
it :: [Int]</code></pre>
<h2 id="binary-operator">Binary operator</h2>
<p>Binary operators can take a type.
Let’s consider the following function:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE RequiredTypeArguments #-}</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="ot">as ::</span> <span class="kw">forall</span> a<span class="op">.</span> a <span class="ot">-&gt;</span> <span class="kw">forall</span> a&#39; <span class="ot">-&gt;</span> a <span class="op">~</span> a&#39; <span class="ot">=&gt;</span> a&#39;</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>as x _ <span class="ot">=</span> x</span></code></pre></div>
<p>This function serves like a type annotation, when used as an infix operator:</p>
<pre><code>ghci&gt; :set +t
ghci&gt; 42 `as` Integer
42
it :: Integer
ghci&gt; 42 `as` Rational
42 % 1
it :: Rational
ghci&gt; 42 `as` Double
42.0
it :: Double</code></pre>
<p>This is not much to be thankful for, but you can easily create function that specify “part of a type”:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE RequiredTypeArguments #-}</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="ot">as&#39; ::</span> <span class="kw">forall</span> f a<span class="op">.</span> f a <span class="ot">-&gt;</span> <span class="kw">forall</span> a&#39; <span class="ot">-&gt;</span> a <span class="op">~</span> a&#39; <span class="ot">=&gt;</span> f a&#39;</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>as&#39; x _ <span class="ot">=</span> x</span></code></pre></div>
<pre><code>ghci&gt; :m + Data.Functor.Identity
ghci&gt; Identity 42 `as&#39;` Int
Identity 42
it :: Identity Int
ghci&gt; Identity 42 `as&#39;` Rational
Identity (42 % 1)
it :: Identity Rational</code></pre>
<p>Of course, specifying part of a type has been possible with <code>PartialTypeSignatures</code> extension.</p>
<h2 id="type-classes">Type classes</h2>
<p>It would be useful to be able to receive the type in a typeclass method.
For example, it would be simpler to write <code>sizeOf Int</code> instead of <code>sizeOf (undefined :: Int)</code>.
Is such a definition possible?</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Hypothetical code</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">NewStorable</span> a <span class="kw">where</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  sizeOf ::</span> <span class="kw">forall</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span></span></code></pre></div>
<p>Unfortunately, this will not work.
The <code>a</code> in typeclass and the <code>a</code> in <code>forall</code> are different variables.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Actual interpretation</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">NewStorable</span> a <span class="kw">where</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  sizeOf ::</span> <span class="kw">forall</span> a&#39; <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- Externally-visible type would be:</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- sizeOf :: forall a. NewStorable a =&gt; forall a&#39; -&gt; Int</span></span></code></pre></div>
<p>The right way is to create a wrapper.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE AllowAmbiguousTypes #-}</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">NewStorable</span> a <span class="kw">where</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  sizeOf_ ::</span> <span class="dt">Int</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- A wrapper</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="ot">sizeOf ::</span> <span class="kw">forall</span> a <span class="ot">-&gt;</span> <span class="dt">NewStorable</span> a <span class="ot">=&gt;</span> <span class="dt">Int</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>sizeOf a <span class="ot">=</span> sizeOf_ <span class="op">@</span>a</span></code></pre></div>
<p>An alternative way is a trick using <code>~</code>:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">NewStorable</span> a <span class="kw">where</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  sizeOf ::</span> <span class="kw">forall</span> a&#39; <span class="ot">-&gt;</span> a <span class="op">~</span> a&#39; <span class="ot">=&gt;</span> <span class="dt">Int</span></span></code></pre></div>
<p>However, using an extra <code>=&gt;</code> may cause subtle differences in intermediate code.
Consider the following code:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE GHC2021 #-}</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE AllowAmbiguousTypes #-}</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE RequiredTypeArguments #-}</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Debug.Trace</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Proxy</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Tagged</span> t a <span class="ot">=</span> <span class="dt">MkTagged</span> {<span class="ot"> unTagged ::</span> a }</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Foo</span> a <span class="kw">where</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a><span class="ot">  someValueAmb ::</span> <span class="dt">Int</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a><span class="ot">  someValueTagged ::</span> <span class="dt">Tagged</span> a <span class="dt">Int</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a><span class="ot">  someValueProxy ::</span> <span class="dt">Proxy</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a><span class="ot">  someValueVis ::</span> <span class="kw">forall</span> a&#39; <span class="ot">-&gt;</span> a <span class="op">~</span> a&#39; <span class="ot">=&gt;</span> <span class="dt">Int</span></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Foo</span> <span class="dt">Float</span> <span class="kw">where</span></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>  someValueAmb <span class="ot">=</span> trace <span class="st">&quot;some heavy computation 1&quot;</span> <span class="dv">42</span></span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>  someValueTagged <span class="ot">=</span> <span class="dt">MkTagged</span> (trace <span class="st">&quot;some heavy computation 2&quot;</span> <span class="dv">42</span>)</span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>  someValueProxy _ <span class="ot">=</span> trace <span class="st">&quot;some heavy computation 3&quot;</span> <span class="dv">42</span></span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>  someValueVis _ <span class="ot">=</span> trace <span class="st">&quot;some heavy computation 4&quot;</span> <span class="dv">42</span></span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> (someValueAmb <span class="op">@</span><span class="dt">Float</span>)</span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> (someValueAmb <span class="op">@</span><span class="dt">Float</span>)</span>
<span id="cb14-25"><a href="#cb14-25" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> (unTagged (<span class="ot">someValueTagged ::</span> <span class="dt">Tagged</span> <span class="dt">Float</span> <span class="dt">Int</span>))</span>
<span id="cb14-26"><a href="#cb14-26" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> (unTagged (<span class="ot">someValueTagged ::</span> <span class="dt">Tagged</span> <span class="dt">Float</span> <span class="dt">Int</span>))</span>
<span id="cb14-27"><a href="#cb14-27" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> (someValueProxy (<span class="dt">Proxy</span> <span class="op">@</span><span class="dt">Float</span>))</span>
<span id="cb14-28"><a href="#cb14-28" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> (someValueProxy (<span class="dt">Proxy</span> <span class="op">@</span><span class="dt">Float</span>))</span>
<span id="cb14-29"><a href="#cb14-29" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> (someValueVis <span class="dt">Float</span>)</span>
<span id="cb14-30"><a href="#cb14-30" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> (someValueVis <span class="dt">Float</span>)</span></code></pre></div>
<p>Suppose <code>someValue</code> is a heavy computation.
In this code, I use <code>trace</code> instead of actual computation.</p>
<p>In <code>main</code>, each <code>someValue</code> is called twice.
How many times will the right side of <code>someValue</code> be evaluated?</p>
<p>If optimizations are enabled, each <code>someValue</code> is evaluated once.</p>
<pre><code>$ ghc-9.10 -O1 Test.hs
$ ./Test
some heavy computation 1
42
42
some heavy computation 2
42
42
some heavy computation 3
42
42
some heavy computation 4
42
42</code></pre>
<p>But what happen if optimizations are disabled?</p>
<pre><code>$ ghc-9.10 -O0 Test.hs
$ ./Test
some heavy computation 1
42
42
some heavy computation 2
42
42
some heavy computation 3
42
some heavy computation 3
42
some heavy computation 4
42
some heavy computation 4
42</code></pre>
<p><code>someValueAmb</code> and <code>someValueTagged</code> were evaluated only once each, whereas <code>someValueProxy</code> and <code>someValueVis</code> were evaluated twice each.
This reflects the difference whether these entities are the value <code>Int</code> or the function <code>_ -&gt; Int</code>.</p>
<p>In a simple program like this, there would be no difference if optimizations are enabled.
But in a more complex and intricate program, the optimizations may not work well enough.
If efficiency is the most important thing to you, you should keep this in mind.</p>
<h2 id="theorem-proving">Theorem proving</h2>
<p>Type-level programming is common in Haskell.
For example, the type-level list concatenation <code>++</code> can be defined as follows:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span><span class="ot"> (++) ::</span> [k] <span class="ot">-&gt;</span> [k] <span class="ot">-&gt;</span> [k]</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> (<span class="op">++</span>) xs ys</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">instance</span> &#39;[] <span class="op">++</span> ys <span class="ot">=</span> ys</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">instance</span> (x &#39;<span class="op">:</span> xs) <span class="op">++</span> ys <span class="ot">=</span> x &#39;<span class="op">:</span> (xs <span class="op">++</span> ys)</span></code></pre></div>
<p>The associativity law <code>xs ++ (ys ++ zs) = (xs ++ ys) ++ zs</code> holds on list concatenation, but GHC’s type checker doesn’t know that.
To teach the type checker an non-trivial equality, we use theorem proving.
That is, we define a function like this:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Type.Equality</span> ((:~:))</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="ot">appendIsAssociative ::</span> <span class="op">...</span> <span class="ot">-&gt;</span> xs <span class="op">++</span> (ys <span class="op">++</span> zs) <span class="op">:~:</span> (xs <span class="op">++</span> ys) <span class="op">++</span> zs</span></code></pre></div>
<p>To prove the associativity, we can use structural induction on <code>xs</code>.
That is, if <code>xs = '[]</code> then it is obvious.
If <code>xs = x : xss</code>, then we can prove the equation with:</p>
<pre><code>(x : xss) ++ (ys ++ zs)
  = x : (xss ++ (ys ++ zs))  (by definition of ++)
  = x : ((xss ++ ys) ++ zs)  (by induction hypothesis)
  = (x : (xss ++ ys)) ++ zs  (by definition of ++)
  = ((x : xss) ++ ys) ++ zs  (by definition of ++)</code></pre>
<p>Now, let’s implement it.
Since we want to prove by case on <code>xs</code>, we define a data type to enable pattern-matching:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">ProxyList</span> xs <span class="kw">where</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">PNil</span><span class="ot"> ::</span> <span class="dt">ProxyList</span> &#39;[]</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">PCons</span><span class="ot"> ::</span> <span class="dt">Proxy</span> x <span class="ot">-&gt;</span> <span class="dt">ProxyList</span> xs <span class="ot">-&gt;</span> <span class="dt">ProxyList</span> (x &#39;<span class="op">:</span> xs)</span></code></pre></div>
<p>On the other hand, we don’t need to do case analysis on <code>ys</code> and <code>zs</code>, the parameter can be something like <code>Proxy</code>.
Therefore, our “proof” will be a function with the following signature:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="ot">appendIsAssociative ::</span> <span class="dt">ProxyList</span> xs <span class="ot">-&gt;</span> proxy2 ys <span class="ot">-&gt;</span> proxy3 zs <span class="ot">-&gt;</span> xs <span class="op">++</span> (ys <span class="op">++</span> zs) <span class="op">:~:</span> (xs <span class="op">++</span> ys) <span class="op">++</span> zs</span></code></pre></div>
<p>The body of the proof, written according to the equational transformation, is as follows:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>appendIsAssociative <span class="dt">PNil</span> _ _ <span class="ot">=</span> <span class="dt">Refl</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>appendIsAssociative (<span class="dt">PCons</span> (<span class="ot">_ ::</span> _ x) (<span class="ot">xss ::</span> _ xss)) (<span class="ot">ys ::</span> _ ys) (<span class="ot">zs ::</span> _ zs) <span class="ot">=</span> <span class="kw">let</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="ot">    pf1 ::</span> (x <span class="op">:</span> xss) <span class="op">++</span> (ys <span class="op">++</span> zs) <span class="op">:~:</span> x <span class="op">:</span> (xss <span class="op">++</span> (ys <span class="op">++</span> zs))</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>    pf1 <span class="ot">=</span> <span class="dt">Refl</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a><span class="ot">    pf2 ::</span> x <span class="op">:</span> (xss <span class="op">++</span> (ys <span class="op">++</span> zs)) <span class="op">:~:</span> x <span class="op">:</span> ((xss <span class="op">++</span> ys) <span class="op">++</span> zs)</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>    pf2 <span class="ot">=</span> apply <span class="dt">Refl</span> (appendIsAssociative xss ys zs)</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a><span class="ot">    pf3 ::</span> x <span class="op">:</span> ((xss <span class="op">++</span> ys) <span class="op">++</span> zs) <span class="op">:~:</span> (x <span class="op">:</span> (xss <span class="op">++</span> ys)) <span class="op">++</span> zs</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>    pf3 <span class="ot">=</span> <span class="dt">Refl</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a><span class="ot">    pf4 ::</span> (x <span class="op">:</span> (xss <span class="op">++</span> ys)) <span class="op">++</span> zs <span class="op">:~:</span> ((x <span class="op">:</span> xss) <span class="op">++</span> ys) <span class="op">++</span> zs</span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>    pf4 <span class="ot">=</span> <span class="dt">Refl</span></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span> pf1 <span class="ot">`trans`</span> pf2 <span class="ot">`trans`</span> pf3 <span class="ot">`trans`</span> pf4</span></code></pre></div>
<p>Now we have the proof, but the above is not very ideal.
We wrote the intermediate types twice each.
Is there any way to simplify the code while maintaining the readability of the proof?</p>
<p>Ideally, I would like to make the equation</p>
<pre><code>(x : xss) ++ (ys ++ zs)
  = x : (xss ++ (ys ++ zs))  (by definition of ++)
  = x : ((xss ++ ys) ++ zs)  (by induction hypothesis)
  = (x : (xss ++ ys)) ++ zs  (by definition of ++)
  = ((x : xss) ++ ys) ++ zs  (by definition of ++)</code></pre>
<p>a valid Haskell code.</p>
<p>Before GHC 9.10, we might have used singleton types for this kind of thing.
But now we have <code>RequiredTypeArguments</code>.
Let’s use <code>RequiredTypeArguments</code> to achieve this notation.</p>
<p>The basic idea is to define operators <code>===</code> and <code>by</code> to have the following expression the type <code>a :~: c</code>:</p>
<pre><code>〈proof of a = b〉 === c `by` 〈proof of b = c〉</code></pre>
<p>We use <code>forall -&gt;</code> in <code>===</code> to receive the type <code>c</code>.
That is, the operators <code>===</code> and <code>by</code> should have the types</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(===) ::</span> a <span class="op">:~:</span> b <span class="ot">-&gt;</span> <span class="kw">forall</span> c <span class="ot">-&gt;</span> <span class="op">???</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="ot">by ::</span> <span class="op">???</span> <span class="ot">-&gt;</span> b <span class="op">:~:</span> c <span class="ot">-&gt;</span> a <span class="op">:~:</span> c</span></code></pre></div>
<p>The <code>???</code> part must contain the information for <code>a</code>, <code>b</code>, <code>c</code>.
Here, I use <code>(a :~: b, Proxy c)</code>.</p>
<p>In summary, the proof can now be written as follows:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE GHC2021 #-}</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DataKinds #-}</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeFamilies #-}</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE RequiredTypeArguments #-}</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE PartialTypeSignatures #-}</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# OPTIONS_GHC -Wno-partial-type-signatures #-}</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Type.Equality</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Proxy</span></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> ((++))</span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span><span class="ot"> (++) ::</span> [k] <span class="ot">-&gt;</span> [k] <span class="ot">-&gt;</span> [k]</span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> (<span class="op">++</span>) xs ys</span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">instance</span> &#39;[] <span class="op">++</span> ys <span class="ot">=</span> ys</span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">instance</span> (x &#39;<span class="op">:</span> xs) <span class="op">++</span> ys <span class="ot">=</span> x &#39;<span class="op">:</span> (xs <span class="op">++</span> ys)</span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-16"><a href="#cb26-16" aria-hidden="true" tabindex="-1"></a><span class="kw">infixl</span> <span class="dv">1</span> <span class="op">===</span>, <span class="ot">`by`</span></span>
<span id="cb26-17"><a href="#cb26-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-18"><a href="#cb26-18" aria-hidden="true" tabindex="-1"></a><span class="ot">(===) ::</span> a <span class="op">:~:</span> b <span class="ot">-&gt;</span> <span class="kw">forall</span> c <span class="ot">-&gt;</span> (a <span class="op">:~:</span> b, <span class="dt">Proxy</span> c)</span>
<span id="cb26-19"><a href="#cb26-19" aria-hidden="true" tabindex="-1"></a>(<span class="op">===</span>) x _ <span class="ot">=</span> (x, <span class="dt">Proxy</span>)</span>
<span id="cb26-20"><a href="#cb26-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-21"><a href="#cb26-21" aria-hidden="true" tabindex="-1"></a><span class="ot">by ::</span> (a <span class="op">:~:</span> b, <span class="dt">Proxy</span> c) <span class="ot">-&gt;</span> b <span class="op">:~:</span> c <span class="ot">-&gt;</span> a <span class="op">:~:</span> c</span>
<span id="cb26-22"><a href="#cb26-22" aria-hidden="true" tabindex="-1"></a>by (<span class="dt">Refl</span>, _) <span class="dt">Refl</span> <span class="ot">=</span> <span class="dt">Refl</span></span>
<span id="cb26-23"><a href="#cb26-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-24"><a href="#cb26-24" aria-hidden="true" tabindex="-1"></a><span class="ot">beginProof ::</span> <span class="kw">forall</span> a <span class="ot">-&gt;</span> a <span class="op">:~:</span> a</span>
<span id="cb26-25"><a href="#cb26-25" aria-hidden="true" tabindex="-1"></a>beginProof _ <span class="ot">=</span> <span class="dt">Refl</span></span>
<span id="cb26-26"><a href="#cb26-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-27"><a href="#cb26-27" aria-hidden="true" tabindex="-1"></a><span class="ot">appendIsAssociative ::</span> <span class="dt">ProxyList</span> xs <span class="ot">-&gt;</span> proxy2 ys <span class="ot">-&gt;</span> proxy3 zs <span class="ot">-&gt;</span> xs <span class="op">++</span> (ys <span class="op">++</span> zs) <span class="op">:~:</span> (xs <span class="op">++</span> ys) <span class="op">++</span> zs</span>
<span id="cb26-28"><a href="#cb26-28" aria-hidden="true" tabindex="-1"></a>appendIsAssociative <span class="dt">PNil</span> _ _ <span class="ot">=</span> <span class="dt">Refl</span></span>
<span id="cb26-29"><a href="#cb26-29" aria-hidden="true" tabindex="-1"></a>appendIsAssociative (<span class="dt">PCons</span> (<span class="ot">_ ::</span> _ x) (<span class="ot">xss_ ::</span> _ xss)) (<span class="ot">ys_ ::</span> _ ys) (<span class="ot">zs_ ::</span> _ zs)</span>
<span id="cb26-30"><a href="#cb26-30" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> beginProof ((x <span class="op">:</span> xss) <span class="op">++</span> (ys <span class="op">++</span> zs))</span>
<span id="cb26-31"><a href="#cb26-31" aria-hidden="true" tabindex="-1"></a>           <span class="op">===</span> x <span class="op">:</span> (xss <span class="op">++</span> (ys <span class="op">++</span> zs)) <span class="ot">`by`</span> <span class="dt">Refl</span></span>
<span id="cb26-32"><a href="#cb26-32" aria-hidden="true" tabindex="-1"></a>           <span class="op">===</span> x <span class="op">:</span> ((xss <span class="op">++</span> ys) <span class="op">++</span> zs) <span class="ot">`by`</span> apply <span class="dt">Refl</span> (appendIsAssociative xss_ ys_ zs_)</span>
<span id="cb26-33"><a href="#cb26-33" aria-hidden="true" tabindex="-1"></a>           <span class="op">===</span> (x <span class="op">:</span> (xss <span class="op">++</span> ys)) <span class="op">++</span> zs <span class="ot">`by`</span> <span class="dt">Refl</span></span>
<span id="cb26-34"><a href="#cb26-34" aria-hidden="true" tabindex="-1"></a>           <span class="op">===</span> ((x <span class="op">:</span> xss) <span class="op">++</span> ys) <span class="op">++</span> zs <span class="ot">`by`</span> <span class="dt">Refl</span></span>
<span id="cb26-35"><a href="#cb26-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-36"><a href="#cb26-36" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">ProxyList</span> xs <span class="kw">where</span> <span class="op">...</span></span></code></pre></div>
<p>There are a couple of remarks:</p>
<ul>
<li>Using type-level <code>++</code> as an argument to <code>forall -&gt;</code> is ambiguous with term-level <code>++</code>. You could use <code>type</code>, but it would be too noisy, so here we hide the <code>++</code> from <code>Prelude</code>.</li>
<li>In the previous code, I used the same variable names at the term level and the type level, like <code>xss :: _ xss</code>, but this is also inconvenient, so I changed the variable names at the term level.</li>
</ul>
<p>Now the proof is cool enough, but can it be improved further?
For example, can we just use <code>appendIsAssociative ...</code> without using <code>apply Refl</code> when applying induction hypothesis?</p>
<p>Yes.
The implementation is as follows:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE GHC2021 #-}</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DataKinds #-}</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeFamilies #-}</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE RequiredTypeArguments #-}</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Type.Equality</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Proxy</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> ((++))</span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span><span class="ot"> (++) ::</span> [k] <span class="ot">-&gt;</span> [k] <span class="ot">-&gt;</span> [k]</span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> (<span class="op">++</span>) xs ys</span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">instance</span> &#39;[] <span class="op">++</span> ys <span class="ot">=</span> ys</span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">instance</span> (x &#39;<span class="op">:</span> xs) <span class="op">++</span> ys <span class="ot">=</span> x &#39;<span class="op">:</span> (xs <span class="op">++</span> ys)</span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true" tabindex="-1"></a><span class="kw">infixl</span> <span class="dv">1</span> <span class="op">===</span>, <span class="ot">`by`</span></span>
<span id="cb27-15"><a href="#cb27-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-16"><a href="#cb27-16" aria-hidden="true" tabindex="-1"></a><span class="ot">(===) ::</span> a <span class="op">:~:</span> b <span class="ot">-&gt;</span> <span class="kw">forall</span> c <span class="ot">-&gt;</span> b <span class="op">~</span> c <span class="ot">=&gt;</span> a <span class="op">:~:</span> c</span>
<span id="cb27-17"><a href="#cb27-17" aria-hidden="true" tabindex="-1"></a>(<span class="op">===</span>) <span class="dt">Refl</span> _ <span class="ot">=</span> <span class="dt">Refl</span></span>
<span id="cb27-18"><a href="#cb27-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-19"><a href="#cb27-19" aria-hidden="true" tabindex="-1"></a><span class="ot">by ::</span> (s <span class="op">~</span> t <span class="ot">=&gt;</span> prop) <span class="ot">-&gt;</span> s <span class="op">:~:</span> t <span class="ot">-&gt;</span> prop</span>
<span id="cb27-20"><a href="#cb27-20" aria-hidden="true" tabindex="-1"></a>by proof <span class="dt">Refl</span> <span class="ot">=</span> proof</span>
<span id="cb27-21"><a href="#cb27-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-22"><a href="#cb27-22" aria-hidden="true" tabindex="-1"></a><span class="ot">beginProof ::</span> <span class="kw">forall</span> a <span class="ot">-&gt;</span> a <span class="op">:~:</span> a</span>
<span id="cb27-23"><a href="#cb27-23" aria-hidden="true" tabindex="-1"></a>beginProof _ <span class="ot">=</span> <span class="dt">Refl</span></span>
<span id="cb27-24"><a href="#cb27-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-25"><a href="#cb27-25" aria-hidden="true" tabindex="-1"></a><span class="ot">appendIsAssociative ::</span> <span class="kw">forall</span> xs <span class="ot">-&gt;</span> <span class="dt">ProxyListI</span> xs <span class="ot">=&gt;</span> <span class="kw">forall</span> ys <span class="ot">-&gt;</span> <span class="kw">forall</span> zs <span class="ot">-&gt;</span> xs <span class="op">++</span> (ys <span class="op">++</span> zs) <span class="op">:~:</span> (xs <span class="op">++</span> ys) <span class="op">++</span> zs</span>
<span id="cb27-26"><a href="#cb27-26" aria-hidden="true" tabindex="-1"></a>appendIsAssociative xs ys zs <span class="ot">=</span> <span class="kw">case</span> proxyList&#39; <span class="op">@</span>xs <span class="kw">of</span></span>
<span id="cb27-27"><a href="#cb27-27" aria-hidden="true" tabindex="-1"></a>  <span class="dt">PNil&#39;</span> <span class="ot">-&gt;</span> <span class="dt">Refl</span></span>
<span id="cb27-28"><a href="#cb27-28" aria-hidden="true" tabindex="-1"></a>  <span class="dt">PCons&#39;</span> <span class="op">@</span>x <span class="op">@</span>xss <span class="ot">-&gt;</span></span>
<span id="cb27-29"><a href="#cb27-29" aria-hidden="true" tabindex="-1"></a>    beginProof ((x <span class="op">:</span> xss) <span class="op">++</span> (ys <span class="op">++</span> zs))</span>
<span id="cb27-30"><a href="#cb27-30" aria-hidden="true" tabindex="-1"></a>           <span class="op">===</span> x <span class="op">:</span> (xss <span class="op">++</span> (ys <span class="op">++</span> zs))</span>
<span id="cb27-31"><a href="#cb27-31" aria-hidden="true" tabindex="-1"></a>           <span class="op">===</span> x <span class="op">:</span> ((xss <span class="op">++</span> ys) <span class="op">++</span> zs) <span class="ot">`by`</span> appendIsAssociative xss ys zs</span>
<span id="cb27-32"><a href="#cb27-32" aria-hidden="true" tabindex="-1"></a>           <span class="op">===</span> (x <span class="op">:</span> (xss <span class="op">++</span> ys)) <span class="op">++</span> zs</span>
<span id="cb27-33"><a href="#cb27-33" aria-hidden="true" tabindex="-1"></a>           <span class="op">===</span> ((x <span class="op">:</span> xss) <span class="op">++</span> ys) <span class="op">++</span> zs</span>
<span id="cb27-34"><a href="#cb27-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-35"><a href="#cb27-35" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">ProxyList&#39;</span> xs <span class="kw">where</span></span>
<span id="cb27-36"><a href="#cb27-36" aria-hidden="true" tabindex="-1"></a>  <span class="dt">PNil&#39;</span><span class="ot"> ::</span> <span class="dt">ProxyList&#39;</span> &#39;[]</span>
<span id="cb27-37"><a href="#cb27-37" aria-hidden="true" tabindex="-1"></a>  <span class="dt">PCons&#39;</span><span class="ot"> ::</span> <span class="kw">forall</span> x xs<span class="op">.</span> <span class="dt">ProxyListI</span> xs <span class="ot">=&gt;</span> <span class="dt">ProxyList&#39;</span> (x &#39;<span class="op">:</span> xs)</span>
<span id="cb27-38"><a href="#cb27-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-39"><a href="#cb27-39" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">ProxyListI</span> xs <span class="kw">where</span></span>
<span id="cb27-40"><a href="#cb27-40" aria-hidden="true" tabindex="-1"></a><span class="ot">  proxyList&#39; ::</span> <span class="dt">ProxyList&#39;</span> xs</span>
<span id="cb27-41"><a href="#cb27-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-42"><a href="#cb27-42" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">ProxyListI</span> &#39;[] <span class="kw">where</span></span>
<span id="cb27-43"><a href="#cb27-43" aria-hidden="true" tabindex="-1"></a>  proxyList&#39; <span class="ot">=</span> <span class="dt">PNil&#39;</span></span>
<span id="cb27-44"><a href="#cb27-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-45"><a href="#cb27-45" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">ProxyListI</span> xs <span class="ot">=&gt;</span> <span class="dt">ProxyListI</span> (x &#39;<span class="op">:</span> xs) <span class="kw">where</span></span>
<span id="cb27-46"><a href="#cb27-46" aria-hidden="true" tabindex="-1"></a>  proxyList&#39; <span class="ot">=</span> <span class="dt">PCons&#39;</span> <span class="op">@</span>x <span class="op">@</span>xs</span></code></pre></div>
<h2 id="acknowledgements">Acknowledgements</h2>
<p>I must thank all the people who worked for GHC 9.10 release, especially Serokell’s GHC team for the work on dependent types.
Thank you!</p>]]></description>
    <pubDate>Sat, 11 May 2024 00:00:00 UT</pubDate>
    <guid>https://minoki.github.io/posts/2024-05-11-playing-with-visible-forall.html</guid>
    <dc:creator>Arata Mizuki</dc:creator>
</item>
<item>
    <title>Introducing LunarML: The Standard ML compiler that produces Lua/JavaScript</title>
    <link>https://minoki.github.io/posts/2023-12-17-lunarml-release.html</link>
    <description><![CDATA[<p>Today I would like to announce the initial release of LunarML, the new Standard ML compiler I have been developing for several years.</p>
<ul>
<li><a href="https://github.com/minoki/LunarML">minoki/LunarML: The Standard ML compiler that produces Lua/JavaScript</a></li>
</ul>
<h2 id="introduction">Introduction</h2>
<p>It is hard to create large software in an untyped language.
However, there are situations where the use of untyped languages is unavoidable due to the constraints of the runtime environment.
This situation can be remedied by a compiler, which converts programs written in statically-typed languages to code in untyped languages.
Such compilers are also called transpilers.</p>
<p>Since JavaScript used to be the only programming language that could be used on the Web, many compilers that compile to JavaScript have appeared.
However, there are still few compilers that output other scripting languages, such as Lua.
Therefore, I decided to create a new compiler that can convert from a statically-typed language to Lua.</p>
<p>As for the input language, I decided to use an existing language instead of creating a new one.
I like ML languages, so after considering several languages in the ML family, I chose Standard ML, which has the following features:</p>
<ul>
<li>Powerful type inference</li>
<li>Strict evaluation</li>
<li>The module system, which allows encapsulation and code reuse</li>
<li>The Definition and multiple conforming implementations</li>
</ul>
<h2 id="features-of-lunarml">Features of LunarML</h2>
<p>LunarML implements all the features of SML ’97 (including the module system) and some features of Successor ML.
It also implements some extensions.</p>
<p>The standard library is still incomplete, but it is functional enough to compile LunarML itself.</p>
<p>To support multi-file projects, LunarML implements ML Basis system (MLB files) compatible with MLton and MLKit.</p>
<p>Of course, a program can interact with the Lua and JavaScript worlds.</p>
<p>Some backends support delimited continuations, which allows integration with async runtimes like Node.js.</p>
<h2 id="build-and-install">Build and Install</h2>
<p>LunarML is developed on GitHub:
<a href="https://github.com/minoki/LunarML" class="uri">https://github.com/minoki/LunarML</a></p>
<p>You need MLton and Lua to build it.</p>
<pre><code>$ git clone https://github.com/minoki/LunarML.git
$ cd LunarML
$ make
$ bin/lunarml compile example/hello.sml
$ lua example/hello.lua
Hello world!</code></pre>
<p>To install LunarML in the system, use <code>make install</code>.
The destination directory can be configured by <code>PREFIX</code> variable (it defaults to <code>/usr/local</code>).</p>
<pre><code>$ make install prefix=/opt/lunarml
$ export PATH=/opt/lunarml/bin:$PATH
$ lunarml compile example/hello.sml</code></pre>
<p>You might not have MLton installed in the system.
In that case, you can follow the alternative method: The Docker image.</p>
<pre><code>$ docker pull ghcr.io/minoki/lunarml:latest
$ docker run --rm --platform linux/amd64 -v &quot;$(pwd)&quot;:/work -w /work ghcr.io/minoki/lunarml:latest lunarml compile example/hello.sml
$ lua example/hello.lua
Hello world!</code></pre>
<p>If you do not have Docker installed, there is yet another method: The precompiled script.
If you have Node.js installed, you can download the tarball and run <code>install-precompiled-node</code> target.</p>
<pre><code>$ curl -LO https://github.com/minoki/LunarML/releases/download/v0.1.0/lunarml-0.1.0.tar.gz
$ tar xf lunarml-0.1.0.tar.gz
$ cd lunarml-0.1.0
$ make install-precompiled-node PREFIX=/opt/lunarml
$ export PATH=/opt/lunarml/bin:$PATH
$ lunarml --help</code></pre>
<p>Warning: The script-compiled LunarML is very slow and you should use native binary for serious use.</p>
<h2 id="compiling-some-code">Compiling some code</h2>
<p>“Hello world” in Standard ML might look like:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode sml"><code class="sourceCode sml"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>print <span class="st">&quot;Hello world!</span><span class="ch">\n</span><span class="st">&quot;</span>;</span></code></pre></div>
<p>Let’s compile this.
You need Lua 5.3 or 5.4 to run the compiled code.</p>
<pre><code>$ lunarml compile hello.sml
$ lua hello.lua
Hello world!</code></pre>
<p>You can also get JavaScript code for Node.js.
Pass the <code>--nodejs</code> or <code>--nodejs-cps</code> option:</p>
<pre><code>$ lunarml compile --nodejs-cps hello.sml
$ node hello.mjs
Hello world!</code></pre>
<p>A (slow) program to compute Fibonacci numbers might look like:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode sml"><code class="sourceCode sml"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> fib <span class="dv">0</span> = <span class="dv">0</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  | fib <span class="dv">1</span> = <span class="dv">1</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  | fib n = fib (n - <span class="dv">1</span>) + fib (n - <span class="dv">2</span>);</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>print (<span class="st">&quot;fib 10 = &quot;</span> ^ Int.toString (fib <span class="dv">10</span>) ^ <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>);</span></code></pre></div>
<pre><code>$ lunarml compile --lua fib10.sml
$ lua fib10.lua                      
fib 10 = 55
$ lunarml compile --nodejs fib10.sml
$ node fib10.mjs
fib 10 = 55</code></pre>
<p>You can use multiple-precision integers (called <code>IntInf</code> in Standard ML).
For Lua target, LunarML uses its own implementation.
For JavaScript target, LunarML uses <code>BigInt</code>.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode sml"><code class="sourceCode sml"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> fact <span class="dv">0</span> : IntInf.<span class="dt">int</span> = <span class="dv">1</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  | fact n = n * fact (n - <span class="dv">1</span>);</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>print (<span class="st">&quot;50! = &quot;</span> ^ IntInf.toString (fact <span class="dv">50</span>) ^ <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>);</span></code></pre></div>
<pre><code>$ lunarml compile --lua fact50.sml
$ lua fact50.lua
50! = 30414093201713378043612608166064768844377641568960512000000000000
$ lunarml compile --nodejs fact50.sml
$ node fact50.mjs
50! = 30414093201713378043612608166064768844377641568960512000000000000</code></pre>
<h2 id="compiling-hamlet">Compiling HaMLet</h2>
<p><a href="https://people.mpi-sws.org/~rossberg/hamlet/">HaMLet</a> is another implementation of Standard ML, written in Standard ML.
Let’s compile HaMLet to Lua.</p>
<pre><code>$ git clone https://github.com/rossberg/hamlet.git
$ cd hamlet/
$ make hamlet.mlb SYSTEM=mlton
$ lunarml compile --lua-continuations hamlet.mlb
$ lua hamlet.lua
HaMLet 2.0.0 - To Be Or Not To Be Standard ML
[loading standard basis library]
- 1 + 1;
val it = 2 : int
- OS.Process.exit OS.Process.success : unit;</code></pre>
<p>Of course, you can also compile it to JavaScript.</p>
<pre><code>$ lunarml compile --nodejs-cps hamlet.mlb
$ node hamlet.mjs
HaMLet 2.0.0 - To Be Or Not To Be Standard ML
[loading standard basis library]
- &quot;Hello &quot; ^ &quot;world!&quot;; 
val it = &quot;Hello world!&quot; : string
- OS.Process.exit OS.Process.success : unit;</code></pre>
<h2 id="generating-lua-code">Generating Lua code</h2>
<p>By default, LunarML produces code for Lua 5.3/5.4.
You can be explicit with the <code>--lua</code> option.</p>
<p>To produce code for LuaJIT, you need to set the <code>--luajit</code> option.</p>
<p>The functionality of Lua can be called via <code>Lua</code> API.
Currently it is not very easy to use, so I may introduce a more convenient way in the future.</p>
<ul>
<li><a href="https://github.com/minoki/LunarML/blob/master/doc/LuaInterface.md">LunarML/doc/LuaInterface.md at master · minoki/LunarML</a></li>
</ul>
<p>You can also generate a Lua module with the <code>--lib</code> option.
Define a variable or module named <code>export</code>, and its content will become accessible from Lua.</p>
<p>A module defined like this</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode sml"><code class="sourceCode sml"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">structure</span> export = <span class="kw">struct</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> hello = <span class="st">&quot;Hello world!&quot;</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> print = TextIO.print</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fun</span> add (x, y) = x + y</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> fun&#39; = <span class="st">&quot;fun!&quot;</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span>;</span></code></pre></div>
<p>will compile to something like this:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode lua"><code class="sourceCode lua"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="cf">return</span> <span class="op">{</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>  <span class="va">hello</span> <span class="op">=</span> <span class="st">&quot;Hello world!&quot;</span><span class="op">,</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="op">=</span> <span class="op">...,</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>  <span class="va">add</span> <span class="op">=</span> <span class="op">...,</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>  <span class="va">fun</span> <span class="op">=</span> <span class="st">&quot;fun!&quot;</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The generated code is not very human readable.
Producing human-readable code is not one of my goals, but I would still like to generate code that is more readable.</p>
<h2 id="generating-javascript-code">Generating JavaScript code</h2>
<p>LunarML can also output JavaScript code.
Currently it requires Node.js for execution and does not work in a browser.
Use the <code>--nodejs</code> or <code>--nodejs-cps</code> option.</p>
<p>Many APIs of Node.js are asynchronous, whereas Standard ML’s input/output functions are synchronous.
To cope with this difference, LunarML performs what is called the CPS conversion on the program when the <code>--nodejs-cps</code> option is used.
If the <code>--nodejs</code> option is specified, it does not perform CPS conversion, but instead restricts the input/output functions.</p>
<p>The functionality of JavaScript can be called via <code>JavaScript</code> API.
I may introduce a more convenient way in the future.</p>
<ul>
<li><a href="https://github.com/minoki/LunarML/blob/master/doc/JavaScriptInterface.md">LunarML/doc/JavaScriptInterface.md at master · minoki/LunarML</a></li>
</ul>
<p>You can generate an ES module via the <code>--lib</code> option.
Define a variable or module named <code>export</code>, and it will be exported.</p>
<p>A module defined like this</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode sml"><code class="sourceCode sml"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">structure</span> export = <span class="kw">struct</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> foo = <span class="dv">42</span> : <span class="dt">int</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> bar = <span class="st">&quot;Hello world!&quot;</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> baz = <span class="st">&quot;Goodbye world!&quot;</span> : WideString.<span class="dt">string</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span>;</span></code></pre></div>
<p>will compile to something like this:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> foo <span class="op">=</span> <span class="dv">42</span><span class="op">;</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> bar <span class="op">=</span> <span class="bu">Uint8Array</span><span class="op">.</span><span class="fu">of</span>(<span class="op">...</span>)<span class="op">;</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> baz <span class="op">=</span> <span class="st">&quot;Goodbye world!&quot;</span><span class="op">;</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="im">export</span> { foo<span class="op">,</span> bar<span class="op">,</span> baz }<span class="op">;</span></span></code></pre></div>
<p>SML’s standard string type <code>string</code> is represented by <code>Uint8Array</code> in JavaScript.
You can use <code>WideString.string</code> type to manipulate JavaScript’s 16-bit string.</p>
<h2 id="future-plans">Future plans</h2>
<p>LunarML is still a work in progress and there are many features that I would like to implement in the future.
Some of them are listed below:</p>
<ul>
<li>More complete standard library</li>
<li>More features of Successor ML</li>
<li>REPL and interpreter</li>
<li>Online compiler</li>
<li>More backends
<ul>
<li>JavaScript for browsers</li>
<li>PHP</li>
<li>WebAssembly with GC</li>
</ul></li>
<li>Package manager</li>
</ul>
<p>Lastly, I would be happy to receive a star on the GitHub repository:</p>
<ul>
<li><a href="https://github.com/minoki/LunarML">minoki/LunarML: The Standard ML compiler that produces Lua/JavaScript</a></li>
</ul>
<p>Thank you for reading!</p>]]></description>
    <pubDate>Sun, 17 Dec 2023 00:00:00 UT</pubDate>
    <guid>https://minoki.github.io/posts/2023-12-17-lunarml-release.html</guid>
    <dc:creator>Arata Mizuki</dc:creator>
</item>

    </channel>
</rss>
