<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta charset="UTF-8" />
        <title>Playing with Visible Forall in GHC 9.10 - Mizuki's Blog</title>
        <link rel="alternate" type="application/rss+xml" title="RSS Feed" href="../rss.xml" />
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">Mizuki's Blog</a>
            </div>
            <div id="navigation">
                <a href="../">Home</a>
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../archive.html">Archive</a>
            </div>
        </div>

        <div id="content">
            <h1>Playing with Visible Forall in GHC 9.10</h1>

            <div class="info">
    Posted on May 11, 2024
    
</div>

<p><em>Japanese version</em>: <a href="https://zenn.dev/mod_poppo/articles/playing-with-visible-forall">GHC 9.10で実装された可視なforallで遊ぶ</a></p>
<p>Today, GHC 9.10.1 is released.
One of the new features is “visible forall”, or <code>RequiredTypeArguments</code> extension.
In this article, I will play with this new feature.</p>
<p>The official documents of this feature are these:</p>
<ul>
<li><a href="https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0281-visible-forall.rst">ghc-proposals/proposals/0281-visible-forall.rst at master · ghc-proposals/ghc-proposals</a></li>
<li><a href="https://downloads.haskell.org/ghc/9.10.1/docs/users_guide/exts/required_type_arguments.html">6.4.18. Required type arguments — Glasgow Haskell Compiler 9.10.1 User’s Guide</a></li>
</ul>
<h2 id="basics-the-identity-function">Basics: The identity function</h2>
<p>The simplest example would be the variant of <code>id</code> function that takes the type explicitly.
The ordinary <code>id</code> function and the variant of <code>id</code> function with visible <code>forall</code> can each be written as follows:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE RequiredTypeArguments #-}</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- From User's Guide:</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- The ordinary id function</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="fu">id</span><span class="ot"> ::</span> <span class="kw">forall</span> a<span class="op">.</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="fu">id</span> x <span class="ot">=</span> x</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="co">-- The id function with visible forall</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="ot">id_vdq ::</span> <span class="kw">forall</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>id_vdq a x <span class="ot">=</span> x</span></code></pre></div>
<p>Let’s try them with GHCi:</p>
<pre><code>ghci&gt; :set +t
ghci&gt; id 42  -- Let GHC infer the type
42
it :: Num a =&gt; a
ghci&gt; id @Int 42  -- Supply the type explicitly
42
it :: Int
ghci&gt; id_vdq _ 42  -- Let GHC infer the type
42
it :: Num w =&gt; w
ghci&gt; id_vdq Int 42  -- Supply the type explicitly (note that there's no `@`!)
42
it :: Int</code></pre>
<p>So, by declaraing a function with <code>forall -&gt;</code>, you can pass the type without using <code>@</code>.</p>
<p>Note that if the same notation is used for a term and a type, the term interpretation takes precedence.
Let’s pass the <code>[Int]</code> type:</p>
<pre><code>ghci&gt; id_vdq [Int] [42]
&lt;interactive&gt;:37:8: error: [GHC-83865]
    • Expected a type, but ‘[Int]’ has kind ‘[*]’
    • In the type ‘[Int]’
      In the expression: id_vdq [Int] [42]
      In an equation for ‘it’: it = id_vdq [Int] [42]</code></pre>
<p>An error occurs because <code>[Int]</code> is interpreted as “a type-level list with <code>Int</code> as an element” instead of “the type of a list consisting of <code>Int</code>”.
There are two ways around this problem.</p>
<p>The first is to use a <code>type</code> expression, which will be available with the <code>ExplicitNamespaces</code> extension.</p>
<pre><code>ghci&gt; :set -XExplicitNamespaces 
ghci&gt; id_vdq (type [Int]) [42]
[42]
it :: [Int]</code></pre>
<p>The other is to stop using the same notation for terms and types.
For list and tuple types, the <code>Prelude.Experimental</code> module provides aliases such as <code>List</code> and <code>Tuple2</code>.</p>
<pre><code>ghci&gt; :m + Prelude.Experimental
ghci&gt; id_vdq (List Int) [42]
[42]
it :: [Int]</code></pre>
<h2 id="binary-operator">Binary operator</h2>
<p>Binary operators can take a type.
Let’s consider the following function:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE RequiredTypeArguments #-}</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="ot">as ::</span> <span class="kw">forall</span> a<span class="op">.</span> a <span class="ot">-&gt;</span> <span class="kw">forall</span> a' <span class="ot">-&gt;</span> a <span class="op">~</span> a' <span class="ot">=&gt;</span> a'</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>as x _ <span class="ot">=</span> x</span></code></pre></div>
<p>This function serves like a type annotation, when used as an infix operator:</p>
<pre><code>ghci&gt; :set +t
ghci&gt; 42 `as` Integer
42
it :: Integer
ghci&gt; 42 `as` Rational
42 % 1
it :: Rational
ghci&gt; 42 `as` Double
42.0
it :: Double</code></pre>
<p>This is not much to be thankful for, but you can easily create function that specify “part of a type”:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE RequiredTypeArguments #-}</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="ot">as' ::</span> <span class="kw">forall</span> f a<span class="op">.</span> f a <span class="ot">-&gt;</span> <span class="kw">forall</span> a' <span class="ot">-&gt;</span> a <span class="op">~</span> a' <span class="ot">=&gt;</span> f a'</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>as' x _ <span class="ot">=</span> x</span></code></pre></div>
<pre><code>ghci&gt; :m + Data.Functor.Identity
ghci&gt; Identity 42 `as'` Int
Identity 42
it :: Identity Int
ghci&gt; Identity 42 `as'` Rational
Identity (42 % 1)
it :: Identity Rational</code></pre>
<p>Of course, specifying part of a type has been possible with <code>PartialTypeSignatures</code> extension.</p>
<h2 id="type-classes">Type classes</h2>
<p>It would be useful to be able to receive the type in a typeclass method.
For example, it would be simpler to write <code>sizeOf Int</code> instead of <code>sizeOf (undefined :: Int)</code>.
Is such a definition possible?</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Hypothetical code</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">NewStorable</span> a <span class="kw">where</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  sizeOf ::</span> <span class="kw">forall</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span></span></code></pre></div>
<p>Unfortunately, this will not work.
The <code>a</code> in typeclass and the <code>a</code> in <code>forall</code> are different variables.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Actual interpretation</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">NewStorable</span> a <span class="kw">where</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  sizeOf ::</span> <span class="kw">forall</span> a' <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- Externally-visible type would be:</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- sizeOf :: forall a. NewStorable a =&gt; forall a' -&gt; Int</span></span></code></pre></div>
<p>The right way is to create a wrapper.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE AllowAmbiguousTypes #-}</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">NewStorable</span> a <span class="kw">where</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  sizeOf_ ::</span> <span class="dt">Int</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- A wrapper</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="ot">sizeOf ::</span> <span class="kw">forall</span> a <span class="ot">-&gt;</span> <span class="dt">NewStorable</span> a <span class="ot">=&gt;</span> <span class="dt">Int</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>sizeOf a <span class="ot">=</span> sizeOf_ <span class="op">@</span>a</span></code></pre></div>
<p>An alternative way is a trick using <code>~</code>:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">NewStorable</span> a <span class="kw">where</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  sizeOf ::</span> <span class="kw">forall</span> a' <span class="ot">-&gt;</span> a <span class="op">~</span> a' <span class="ot">=&gt;</span> <span class="dt">Int</span></span></code></pre></div>
<p>However, using an extra <code>=&gt;</code> may cause subtle differences in intermediate code.
Consider the following code:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE GHC2021 #-}</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE AllowAmbiguousTypes #-}</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE RequiredTypeArguments #-}</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Debug.Trace</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Proxy</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Tagged</span> t a <span class="ot">=</span> <span class="dt">MkTagged</span> {<span class="ot"> unTagged ::</span> a }</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Foo</span> a <span class="kw">where</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a><span class="ot">  someValueAmb ::</span> <span class="dt">Int</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a><span class="ot">  someValueTagged ::</span> <span class="dt">Tagged</span> a <span class="dt">Int</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a><span class="ot">  someValueProxy ::</span> <span class="dt">Proxy</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a><span class="ot">  someValueVis ::</span> <span class="kw">forall</span> a' <span class="ot">-&gt;</span> a <span class="op">~</span> a' <span class="ot">=&gt;</span> <span class="dt">Int</span></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Foo</span> <span class="dt">Float</span> <span class="kw">where</span></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>  someValueAmb <span class="ot">=</span> trace <span class="st">&quot;some heavy computation 1&quot;</span> <span class="dv">42</span></span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>  someValueTagged <span class="ot">=</span> <span class="dt">MkTagged</span> (trace <span class="st">&quot;some heavy computation 2&quot;</span> <span class="dv">42</span>)</span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>  someValueProxy _ <span class="ot">=</span> trace <span class="st">&quot;some heavy computation 3&quot;</span> <span class="dv">42</span></span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>  someValueVis _ <span class="ot">=</span> trace <span class="st">&quot;some heavy computation 4&quot;</span> <span class="dv">42</span></span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> (someValueAmb <span class="op">@</span><span class="dt">Float</span>)</span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> (someValueAmb <span class="op">@</span><span class="dt">Float</span>)</span>
<span id="cb14-25"><a href="#cb14-25" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> (unTagged (<span class="ot">someValueTagged ::</span> <span class="dt">Tagged</span> <span class="dt">Float</span> <span class="dt">Int</span>))</span>
<span id="cb14-26"><a href="#cb14-26" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> (unTagged (<span class="ot">someValueTagged ::</span> <span class="dt">Tagged</span> <span class="dt">Float</span> <span class="dt">Int</span>))</span>
<span id="cb14-27"><a href="#cb14-27" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> (someValueProxy (<span class="dt">Proxy</span> <span class="op">@</span><span class="dt">Float</span>))</span>
<span id="cb14-28"><a href="#cb14-28" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> (someValueProxy (<span class="dt">Proxy</span> <span class="op">@</span><span class="dt">Float</span>))</span>
<span id="cb14-29"><a href="#cb14-29" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> (someValueVis <span class="dt">Float</span>)</span>
<span id="cb14-30"><a href="#cb14-30" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> (someValueVis <span class="dt">Float</span>)</span></code></pre></div>
<p>Suppose <code>someValue</code> is a heavy computation.
In this code, I use <code>trace</code> instead of actual computation.</p>
<p>In <code>main</code>, each <code>someValue</code> is called twice.
How many times will the right side of <code>someValue</code> be evaluated?</p>
<p>If optimizations are enabled, each <code>someValue</code> is evaluated once.</p>
<pre><code>$ ghc-9.10 -O1 Test.hs
$ ./Test
some heavy computation 1
42
42
some heavy computation 2
42
42
some heavy computation 3
42
42
some heavy computation 4
42
42</code></pre>
<p>But what happen if optimizations are disabled?</p>
<pre><code>$ ghc-9.10 -O0 Test.hs
$ ./Test
some heavy computation 1
42
42
some heavy computation 2
42
42
some heavy computation 3
42
some heavy computation 3
42
some heavy computation 4
42
some heavy computation 4
42</code></pre>
<p><code>someValueAmb</code> and <code>someValueTagged</code> were evaluated only once each, whereas <code>someValueProxy</code> and <code>someValueVis</code> were evaluated twice each.
This reflects the difference whether these entities are the value <code>Int</code> or the function <code>_ -&gt; Int</code>.</p>
<p>In a simple program like this, there would be no difference if optimizations are enabled.
But in a more complex and intricate program, the optimizations may not work well enough.
If efficiency is the most important thing to you, you should keep this in mind.</p>
<h2 id="theorem-proving">Theorem proving</h2>
<p>Type-level programming is common in Haskell.
For example, the type-level list concatenation <code>++</code> can be defined as follows:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span><span class="ot"> (++) ::</span> [k] <span class="ot">-&gt;</span> [k] <span class="ot">-&gt;</span> [k]</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> (<span class="op">++</span>) xs ys</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">instance</span> '[] <span class="op">++</span> ys <span class="ot">=</span> ys</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">instance</span> (x '<span class="op">:</span> xs) <span class="op">++</span> ys <span class="ot">=</span> x '<span class="op">:</span> (xs <span class="op">++</span> ys)</span></code></pre></div>
<p>The associativity law <code>xs ++ (ys ++ zs) = (xs ++ ys) ++ zs</code> holds on list concatenation, but GHC’s type checker doesn’t know that.
To teach the type checker an non-trivial equality, we use theorem proving.
That is, we define a function like this:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Type.Equality</span> ((:~:))</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="ot">appendIsAssociative ::</span> <span class="op">...</span> <span class="ot">-&gt;</span> xs <span class="op">++</span> (ys <span class="op">++</span> zs) <span class="op">:~:</span> (xs <span class="op">++</span> ys) <span class="op">++</span> zs</span></code></pre></div>
<p>To prove the associativity, we can use structural induction on <code>xs</code>.
That is, if <code>xs = '[]</code> then it is obvious.
If <code>xs = x : xss</code>, then we can prove the equation with:</p>
<pre><code>(x : xss) ++ (ys ++ zs)
  = x : (xss ++ (ys ++ zs))  (by definition of ++)
  = x : ((xss ++ ys) ++ zs)  (by induction hypothesis)
  = (x : (xss ++ ys)) ++ zs  (by definition of ++)
  = ((x : xss) ++ ys) ++ zs  (by definition of ++)</code></pre>
<p>Now, let’s implement it.
Since we want to prove by case on <code>xs</code>, we define a data type to enable pattern-matching:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">ProxyList</span> xs <span class="kw">where</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">PNil</span><span class="ot"> ::</span> <span class="dt">ProxyList</span> '[]</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">PCons</span><span class="ot"> ::</span> <span class="dt">Proxy</span> x <span class="ot">-&gt;</span> <span class="dt">ProxyList</span> xs <span class="ot">-&gt;</span> <span class="dt">ProxyList</span> (x '<span class="op">:</span> xs)</span></code></pre></div>
<p>On the other hand, we don’t need to do case analysis on <code>ys</code> and <code>zs</code>, the parameter can be something like <code>Proxy</code>.
Therefore, our “proof” will be a function with the following signature:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="ot">appendIsAssociative ::</span> <span class="dt">ProxyList</span> xs <span class="ot">-&gt;</span> proxy2 ys <span class="ot">-&gt;</span> proxy3 zs <span class="ot">-&gt;</span> xs <span class="op">++</span> (ys <span class="op">++</span> zs) <span class="op">:~:</span> (xs <span class="op">++</span> ys) <span class="op">++</span> zs</span></code></pre></div>
<p>The body of the proof, written according to the equational transformation, is as follows:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>appendIsAssociative <span class="dt">PNil</span> _ _ <span class="ot">=</span> <span class="dt">Refl</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>appendIsAssociative (<span class="dt">PCons</span> (<span class="ot">_ ::</span> _ x) (<span class="ot">xss ::</span> _ xss)) (<span class="ot">ys ::</span> _ ys) (<span class="ot">zs ::</span> _ zs) <span class="ot">=</span> <span class="kw">let</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="ot">    pf1 ::</span> (x <span class="op">:</span> xss) <span class="op">++</span> (ys <span class="op">++</span> zs) <span class="op">:~:</span> x <span class="op">:</span> (xss <span class="op">++</span> (ys <span class="op">++</span> zs))</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>    pf1 <span class="ot">=</span> <span class="dt">Refl</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a><span class="ot">    pf2 ::</span> x <span class="op">:</span> (xss <span class="op">++</span> (ys <span class="op">++</span> zs)) <span class="op">:~:</span> x <span class="op">:</span> ((xss <span class="op">++</span> ys) <span class="op">++</span> zs)</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>    pf2 <span class="ot">=</span> apply <span class="dt">Refl</span> (appendIsAssociative xss ys zs)</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a><span class="ot">    pf3 ::</span> x <span class="op">:</span> ((xss <span class="op">++</span> ys) <span class="op">++</span> zs) <span class="op">:~:</span> (x <span class="op">:</span> (xss <span class="op">++</span> ys)) <span class="op">++</span> zs</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>    pf3 <span class="ot">=</span> <span class="dt">Refl</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a><span class="ot">    pf4 ::</span> (x <span class="op">:</span> (xss <span class="op">++</span> ys)) <span class="op">++</span> zs <span class="op">:~:</span> ((x <span class="op">:</span> xss) <span class="op">++</span> ys) <span class="op">++</span> zs</span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>    pf4 <span class="ot">=</span> <span class="dt">Refl</span></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span> pf1 <span class="ot">`trans`</span> pf2 <span class="ot">`trans`</span> pf3 <span class="ot">`trans`</span> pf4</span></code></pre></div>
<p>Now we have the proof, but the above is not very ideal.
We wrote the intermediate types twice each.
Is there any way to simplify the code while maintaining the readability of the proof?</p>
<p>Ideally, I would like to make the equation</p>
<pre><code>(x : xss) ++ (ys ++ zs)
  = x : (xss ++ (ys ++ zs))  (by definition of ++)
  = x : ((xss ++ ys) ++ zs)  (by induction hypothesis)
  = (x : (xss ++ ys)) ++ zs  (by definition of ++)
  = ((x : xss) ++ ys) ++ zs  (by definition of ++)</code></pre>
<p>a valid Haskell code.</p>
<p>Before GHC 9.10, we might have used singleton types for this kind of thing.
But now we have <code>RequiredTypeArguments</code>.
Let’s use <code>RequiredTypeArguments</code> to achieve this notation.</p>
<p>The basic idea is to define operators <code>===</code> and <code>by</code> to have the following expression the type <code>a :~: c</code>:</p>
<pre><code>〈proof of a = b〉 === c `by` 〈proof of b = c〉</code></pre>
<p>We use <code>forall -&gt;</code> in <code>===</code> to receive the type <code>c</code>.
That is, the operators <code>===</code> and <code>by</code> should have the types</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(===) ::</span> a <span class="op">:~:</span> b <span class="ot">-&gt;</span> <span class="kw">forall</span> c <span class="ot">-&gt;</span> <span class="op">???</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="ot">by ::</span> <span class="op">???</span> <span class="ot">-&gt;</span> b <span class="op">:~:</span> c <span class="ot">-&gt;</span> a <span class="op">:~:</span> c</span></code></pre></div>
<p>The <code>???</code> part must contain the information for <code>a</code>, <code>b</code>, <code>c</code>.
Here, I use <code>(a :~: b, Proxy c)</code>.</p>
<p>In summary, the proof can now be written as follows:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE GHC2021 #-}</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DataKinds #-}</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeFamilies #-}</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE RequiredTypeArguments #-}</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE PartialTypeSignatures #-}</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# OPTIONS_GHC -Wno-partial-type-signatures #-}</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Type.Equality</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Proxy</span></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> ((++))</span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span><span class="ot"> (++) ::</span> [k] <span class="ot">-&gt;</span> [k] <span class="ot">-&gt;</span> [k]</span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> (<span class="op">++</span>) xs ys</span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">instance</span> '[] <span class="op">++</span> ys <span class="ot">=</span> ys</span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">instance</span> (x '<span class="op">:</span> xs) <span class="op">++</span> ys <span class="ot">=</span> x '<span class="op">:</span> (xs <span class="op">++</span> ys)</span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-16"><a href="#cb26-16" aria-hidden="true" tabindex="-1"></a><span class="kw">infixl</span> <span class="dv">1</span> <span class="op">===</span>, <span class="ot">`by`</span></span>
<span id="cb26-17"><a href="#cb26-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-18"><a href="#cb26-18" aria-hidden="true" tabindex="-1"></a><span class="ot">(===) ::</span> a <span class="op">:~:</span> b <span class="ot">-&gt;</span> <span class="kw">forall</span> c <span class="ot">-&gt;</span> (a <span class="op">:~:</span> b, <span class="dt">Proxy</span> c)</span>
<span id="cb26-19"><a href="#cb26-19" aria-hidden="true" tabindex="-1"></a>(<span class="op">===</span>) x _ <span class="ot">=</span> (x, <span class="dt">Proxy</span>)</span>
<span id="cb26-20"><a href="#cb26-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-21"><a href="#cb26-21" aria-hidden="true" tabindex="-1"></a><span class="ot">by ::</span> (a <span class="op">:~:</span> b, <span class="dt">Proxy</span> c) <span class="ot">-&gt;</span> b <span class="op">:~:</span> c <span class="ot">-&gt;</span> a <span class="op">:~:</span> c</span>
<span id="cb26-22"><a href="#cb26-22" aria-hidden="true" tabindex="-1"></a>by (<span class="dt">Refl</span>, _) <span class="dt">Refl</span> <span class="ot">=</span> <span class="dt">Refl</span></span>
<span id="cb26-23"><a href="#cb26-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-24"><a href="#cb26-24" aria-hidden="true" tabindex="-1"></a><span class="ot">beginProof ::</span> <span class="kw">forall</span> a <span class="ot">-&gt;</span> a <span class="op">:~:</span> a</span>
<span id="cb26-25"><a href="#cb26-25" aria-hidden="true" tabindex="-1"></a>beginProof _ <span class="ot">=</span> <span class="dt">Refl</span></span>
<span id="cb26-26"><a href="#cb26-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-27"><a href="#cb26-27" aria-hidden="true" tabindex="-1"></a><span class="ot">appendIsAssociative ::</span> <span class="dt">ProxyList</span> xs <span class="ot">-&gt;</span> proxy2 ys <span class="ot">-&gt;</span> proxy3 zs <span class="ot">-&gt;</span> xs <span class="op">++</span> (ys <span class="op">++</span> zs) <span class="op">:~:</span> (xs <span class="op">++</span> ys) <span class="op">++</span> zs</span>
<span id="cb26-28"><a href="#cb26-28" aria-hidden="true" tabindex="-1"></a>appendIsAssociative <span class="dt">PNil</span> _ _ <span class="ot">=</span> <span class="dt">Refl</span></span>
<span id="cb26-29"><a href="#cb26-29" aria-hidden="true" tabindex="-1"></a>appendIsAssociative (<span class="dt">PCons</span> (<span class="ot">_ ::</span> _ x) (<span class="ot">xss_ ::</span> _ xss)) (<span class="ot">ys_ ::</span> _ ys) (<span class="ot">zs_ ::</span> _ zs)</span>
<span id="cb26-30"><a href="#cb26-30" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> beginProof ((x <span class="op">:</span> xss) <span class="op">++</span> (ys <span class="op">++</span> zs))</span>
<span id="cb26-31"><a href="#cb26-31" aria-hidden="true" tabindex="-1"></a>           <span class="op">===</span> x <span class="op">:</span> (xss <span class="op">++</span> (ys <span class="op">++</span> zs)) <span class="ot">`by`</span> <span class="dt">Refl</span></span>
<span id="cb26-32"><a href="#cb26-32" aria-hidden="true" tabindex="-1"></a>           <span class="op">===</span> x <span class="op">:</span> ((xss <span class="op">++</span> ys) <span class="op">++</span> zs) <span class="ot">`by`</span> apply <span class="dt">Refl</span> (appendIsAssociative xss_ ys_ zs_)</span>
<span id="cb26-33"><a href="#cb26-33" aria-hidden="true" tabindex="-1"></a>           <span class="op">===</span> (x <span class="op">:</span> (xss <span class="op">++</span> ys)) <span class="op">++</span> zs <span class="ot">`by`</span> <span class="dt">Refl</span></span>
<span id="cb26-34"><a href="#cb26-34" aria-hidden="true" tabindex="-1"></a>           <span class="op">===</span> ((x <span class="op">:</span> xss) <span class="op">++</span> ys) <span class="op">++</span> zs <span class="ot">`by`</span> <span class="dt">Refl</span></span>
<span id="cb26-35"><a href="#cb26-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-36"><a href="#cb26-36" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">ProxyList</span> xs <span class="kw">where</span> <span class="op">...</span></span></code></pre></div>
<p>There are a couple of remarks:</p>
<ul>
<li>Using type-level <code>++</code> as an argument to <code>forall -&gt;</code> is ambiguous with term-level <code>++</code>. You could use <code>type</code>, but it would be too noisy, so here we hide the <code>++</code> from <code>Prelude</code>.</li>
<li>In the previous code, I used the same variable names at the term level and the type level, like <code>xss :: _ xss</code>, but this is also inconvenient, so I changed the variable names at the term level.</li>
</ul>
<p>Now the proof is cool enough, but can it be improved further?
For example, can we just use <code>appendIsAssociative ...</code> without using <code>apply Refl</code> when applying induction hypothesis?</p>
<p>Yes.
The implementation is as follows:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE GHC2021 #-}</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DataKinds #-}</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeFamilies #-}</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE RequiredTypeArguments #-}</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Type.Equality</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Proxy</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> ((++))</span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span><span class="ot"> (++) ::</span> [k] <span class="ot">-&gt;</span> [k] <span class="ot">-&gt;</span> [k]</span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> (<span class="op">++</span>) xs ys</span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">instance</span> '[] <span class="op">++</span> ys <span class="ot">=</span> ys</span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">instance</span> (x '<span class="op">:</span> xs) <span class="op">++</span> ys <span class="ot">=</span> x '<span class="op">:</span> (xs <span class="op">++</span> ys)</span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true" tabindex="-1"></a><span class="kw">infixl</span> <span class="dv">1</span> <span class="op">===</span>, <span class="ot">`by`</span></span>
<span id="cb27-15"><a href="#cb27-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-16"><a href="#cb27-16" aria-hidden="true" tabindex="-1"></a><span class="ot">(===) ::</span> a <span class="op">:~:</span> b <span class="ot">-&gt;</span> <span class="kw">forall</span> c <span class="ot">-&gt;</span> b <span class="op">~</span> c <span class="ot">=&gt;</span> a <span class="op">:~:</span> c</span>
<span id="cb27-17"><a href="#cb27-17" aria-hidden="true" tabindex="-1"></a>(<span class="op">===</span>) <span class="dt">Refl</span> _ <span class="ot">=</span> <span class="dt">Refl</span></span>
<span id="cb27-18"><a href="#cb27-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-19"><a href="#cb27-19" aria-hidden="true" tabindex="-1"></a><span class="ot">by ::</span> (s <span class="op">~</span> t <span class="ot">=&gt;</span> prop) <span class="ot">-&gt;</span> s <span class="op">:~:</span> t <span class="ot">-&gt;</span> prop</span>
<span id="cb27-20"><a href="#cb27-20" aria-hidden="true" tabindex="-1"></a>by proof <span class="dt">Refl</span> <span class="ot">=</span> proof</span>
<span id="cb27-21"><a href="#cb27-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-22"><a href="#cb27-22" aria-hidden="true" tabindex="-1"></a><span class="ot">beginProof ::</span> <span class="kw">forall</span> a <span class="ot">-&gt;</span> a <span class="op">:~:</span> a</span>
<span id="cb27-23"><a href="#cb27-23" aria-hidden="true" tabindex="-1"></a>beginProof _ <span class="ot">=</span> <span class="dt">Refl</span></span>
<span id="cb27-24"><a href="#cb27-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-25"><a href="#cb27-25" aria-hidden="true" tabindex="-1"></a><span class="ot">appendIsAssociative ::</span> <span class="kw">forall</span> xs <span class="ot">-&gt;</span> <span class="dt">ProxyListI</span> xs <span class="ot">=&gt;</span> <span class="kw">forall</span> ys <span class="ot">-&gt;</span> <span class="kw">forall</span> zs <span class="ot">-&gt;</span> xs <span class="op">++</span> (ys <span class="op">++</span> zs) <span class="op">:~:</span> (xs <span class="op">++</span> ys) <span class="op">++</span> zs</span>
<span id="cb27-26"><a href="#cb27-26" aria-hidden="true" tabindex="-1"></a>appendIsAssociative xs ys zs <span class="ot">=</span> <span class="kw">case</span> proxyList' <span class="op">@</span>xs <span class="kw">of</span></span>
<span id="cb27-27"><a href="#cb27-27" aria-hidden="true" tabindex="-1"></a>  <span class="dt">PNil'</span> <span class="ot">-&gt;</span> <span class="dt">Refl</span></span>
<span id="cb27-28"><a href="#cb27-28" aria-hidden="true" tabindex="-1"></a>  <span class="dt">PCons'</span> <span class="op">@</span>x <span class="op">@</span>xss <span class="ot">-&gt;</span></span>
<span id="cb27-29"><a href="#cb27-29" aria-hidden="true" tabindex="-1"></a>    beginProof ((x <span class="op">:</span> xss) <span class="op">++</span> (ys <span class="op">++</span> zs))</span>
<span id="cb27-30"><a href="#cb27-30" aria-hidden="true" tabindex="-1"></a>           <span class="op">===</span> x <span class="op">:</span> (xss <span class="op">++</span> (ys <span class="op">++</span> zs))</span>
<span id="cb27-31"><a href="#cb27-31" aria-hidden="true" tabindex="-1"></a>           <span class="op">===</span> x <span class="op">:</span> ((xss <span class="op">++</span> ys) <span class="op">++</span> zs) <span class="ot">`by`</span> appendIsAssociative xss ys zs</span>
<span id="cb27-32"><a href="#cb27-32" aria-hidden="true" tabindex="-1"></a>           <span class="op">===</span> (x <span class="op">:</span> (xss <span class="op">++</span> ys)) <span class="op">++</span> zs</span>
<span id="cb27-33"><a href="#cb27-33" aria-hidden="true" tabindex="-1"></a>           <span class="op">===</span> ((x <span class="op">:</span> xss) <span class="op">++</span> ys) <span class="op">++</span> zs</span>
<span id="cb27-34"><a href="#cb27-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-35"><a href="#cb27-35" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">ProxyList'</span> xs <span class="kw">where</span></span>
<span id="cb27-36"><a href="#cb27-36" aria-hidden="true" tabindex="-1"></a>  <span class="dt">PNil'</span><span class="ot"> ::</span> <span class="dt">ProxyList'</span> '[]</span>
<span id="cb27-37"><a href="#cb27-37" aria-hidden="true" tabindex="-1"></a>  <span class="dt">PCons'</span><span class="ot"> ::</span> <span class="kw">forall</span> x xs<span class="op">.</span> <span class="dt">ProxyListI</span> xs <span class="ot">=&gt;</span> <span class="dt">ProxyList'</span> (x '<span class="op">:</span> xs)</span>
<span id="cb27-38"><a href="#cb27-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-39"><a href="#cb27-39" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">ProxyListI</span> xs <span class="kw">where</span></span>
<span id="cb27-40"><a href="#cb27-40" aria-hidden="true" tabindex="-1"></a><span class="ot">  proxyList' ::</span> <span class="dt">ProxyList'</span> xs</span>
<span id="cb27-41"><a href="#cb27-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-42"><a href="#cb27-42" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">ProxyListI</span> '[] <span class="kw">where</span></span>
<span id="cb27-43"><a href="#cb27-43" aria-hidden="true" tabindex="-1"></a>  proxyList' <span class="ot">=</span> <span class="dt">PNil'</span></span>
<span id="cb27-44"><a href="#cb27-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-45"><a href="#cb27-45" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">ProxyListI</span> xs <span class="ot">=&gt;</span> <span class="dt">ProxyListI</span> (x '<span class="op">:</span> xs) <span class="kw">where</span></span>
<span id="cb27-46"><a href="#cb27-46" aria-hidden="true" tabindex="-1"></a>  proxyList' <span class="ot">=</span> <span class="dt">PCons'</span> <span class="op">@</span>x <span class="op">@</span>xs</span></code></pre></div>
<h2 id="acknowledgements">Acknowledgements</h2>
<p>I must thank all the people who worked for GHC 9.10 release, especially Serokell’s GHC team for the work on dependent types.
Thank you!</p>

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
